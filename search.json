[{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/benchmark.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Benchmarking Pv3Rs","text":"","code":"library(Pv3Rs) library(tictoc) library(gtools)  # simulate allele frequencies for one marker sim_fs_single <- function(n_a) {   alleles <- letters[1:n_a] # n_a <= 26   fs_unnamed <- as.vector(rdirichlet(1, alpha = rep(1, n_a)))   setNames(fs_unnamed, alleles) }  # simulate allele frequencies for multiple markers # assumes each marker has the same number of alleles sim_fs <- function(n_m, n_a) {   markers <- paste0(\"m\", 1:n_m) # marker names   n_a_vec <- setNames(rep(n_a, n_m), markers)   lapply(n_a_vec, sim_fs_single) }  # simulate data for one marker, one episode # sample without replacement to match desired MOI, so must have length(fs) >= MOI sim_data_single <- function(fs_single, MOI) {   sample(names(fs_single), MOI, prob=fs_single) }  # simulate data for all markers, all episodes sim_data <- function(MOIs, n_m, n_a) {   fs <- sim_fs(n_m, n_a)   y <- lapply(     MOIs,     function(MOI) lapply(fs, sim_data_single, MOI) # sample data for one episode   )   return(list(y=y, fs=fs)) }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/benchmark.html","id":"runtime-vs-number-of-markers","dir":"Articles","previous_headings":"","what":"Runtime vs number of markers","title":"Benchmarking Pv3Rs","text":"expect runtime compute_posterior scale linearly number markers due likelihood decomposition (Section 3.4 Taylor, Foo & White, 2022). simulate genetic data spanning across 2 episodes MOI 2, vary number markers 50,100,…,40050, 100, \\ldots, 400. marker assumed 8 possible alleles.","code":"set.seed(1) n_markers <- 50*(1:8) n_a <- 8 MOIs <- c(2, 2) n_rep <- 30  data_by_m <- list() for (n_m in n_markers) {   data_by_m[[as.character(n_m)]] <- lapply(     1:n_rep,     function(x) sim_data(MOIs, n_m, n_a)   ) } time_by_m <- list() for (n_m in n_markers) {   time_by_m[[as.character(n_m)]] <- sapply(     data_by_m[[as.character(n_m)]],     function(data) {       tic(\"\")       suppressMessages(compute_posterior(data$y, data$fs))       res <- toc(quiet=TRUE)       res$toc - res$tic     }   ) } max_time <- max(sapply(time_by_m, max)) par(cex=1.0, mar=c(5, 4.5, 2, 1)) plot(   NULL, type=\"n\",    xlim=c(0, 420),    ylim=c(0, max_time*1.05),   xlab=\"Number of markers\",   ylab=\"Runtime (s)\" ) for(n_m in n_markers) {   points(rep(n_m, n_rep), time_by_m[[as.character(n_m)]], pch=20) }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/benchmark.html","id":"runtime-vs-mois","dir":"Articles","previous_headings":"","what":"Runtime vs MOIs","title":"Benchmarking Pv3Rs","text":"number MOIs increase, runtime increases due possibilities allele assignment valid relationship graphs. simulate genetic data consisting 1 marker (8 alleles), spanning 2 episodes various MOI combinations.  Empirically, runtime (note log scale) roughly exponentially scaling respect total MOI. difficult conclude exact growth rate due small range total MOI. Given fixed total MOI, runtime slightly shorter (see printed output total runtime) maximum MOI larger. can explained following observations: larger maximum MOI leads pairs genotypes clones. leads fewer valid relationship graphs enumerate. Allele assignment largest MOI always fixed. smaller minimum MOI leads fewer allele assignment possibilities considered.","code":"set.seed(1) n_m <- 1 n_a <- 8 MOIs_comb <- list() for(MOItot in 3:7) {   for(MOI1 in (MOItot-1):1) {     MOI2 <- MOItot-MOI1     if(MOI1 >= MOI2) MOIs_comb <- c(MOIs_comb, list(c(MOI1, MOI2)))   } } n_rep <- 30  data_by_MOI <- list() for (MOIs in MOIs_comb) {   data_by_MOI[[paste(MOIs, collapse=\",\")]] <- lapply(     1:n_rep,     function(x) sim_data(MOIs, n_m, n_a)   ) } time_by_MOI <- list() for (MOIs in MOIs_comb) {   MOIstr <- paste(MOIs, collapse=\",\")   time_by_MOI[[MOIstr]] <- sapply(     data_by_MOI[[MOIstr]],     function(data) {       tic(\"\")       suppressMessages(compute_posterior(data$y, data$fs))       res <- toc(quiet=TRUE)       res$toc - res$tic     }   ) } min_time <- min(sapply(time_by_MOI, min)) max_time <- max(sapply(time_by_MOI, max)) n <- length(MOIs_comb)  par(cex=1.0, cex.axis=0.8, mar=c(5, 4.5, 2, 1)) plot(   1, 1, type=\"n\",    xlim=c(0.5, n+0.5),    ylim=c(min_time*0.5, max_time*2),   xlab=\"MOIs\",   ylab=\"Runtime (s)\",   xaxt='n', log=\"y\", ) axis(   side=1, at=1:n,   sapply(MOIs_comb, paste, collapse=\",\") )  for(i in 1:n) {   points(rep(i, n_rep), time_by_MOI[[i]], pch=20) }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/benchmark.html","id":"runtime-vs-number-of-episodes","dir":"Articles","previous_headings":"","what":"Runtime vs number of episodes","title":"Benchmarking Pv3Rs","text":"investigate two separate cases: increasing number episodes 1 genotype per episode, increasing number episodes fixed total MOI.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/benchmark.html","id":"one-genotype-per-episode-episodes-with-moi-1","dir":"Articles","previous_headings":"Runtime vs number of episodes","what":"One genotype per episode (episodes with MOI = 1)","title":"Benchmarking Pv3Rs","text":"simulate genetic data consisting one marker (eight alleles), one genotype per episode various numbers episodes.  one genotype per episode, runtime (note log scale) scales super-exponentially respect number episodes (equivalently, total MOI). fact, number relationship graphs nn episodes one genotype per episode given Rn=∑k=1nS(n,k)Bk,R_n = \\sum_{k=1}^n S(n,k)B_k, S(nk)S(n_k) Stirling numbers second kind BkB_k Bell numbers. provide derivation Appendix, also show logRn∼nlogn\\log R_n \\sim n\\log n.","code":"set.seed(1) n_m <- 1 n_a <- 8 n_epis <- 2:7 n_rep <- 30  data_by_epi <- list() for (epi in n_epis) {   data_by_epi[[as.character(epi)]] <- lapply(     1:n_rep,     function(x) sim_data(rep(1, epi), n_m, n_a)   ) } time_by_epi <- list() for (epi in n_epis) {   time_by_epi[[as.character(epi)]] <- sapply(     data_by_epi[[as.character(epi)]],     function(data) {       tic(\"\")       suppressMessages(compute_posterior(data$y, data$fs))       res <- toc(quiet=TRUE)       res$toc - res$tic     }   ) } min_time <- min(sapply(time_by_epi, min)) max_time <- max(sapply(time_by_epi, max))  par(cex=1.0, mar=c(5, 4.5, 2, 1)) plot(   1, 1, type=\"n\",    xlim=c(1.5, 7.5),    ylim=c(min_time*0.5, max_time*2),   xlab=\"Number of monoclonal episodes\",   ylab=\"Runtime (s)\",   log=\"y\", )  for(epi in n_epis) {   points(rep(epi, n_rep), time_by_epi[[as.character(epi)]], pch=20) }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/benchmark.html","id":"fixed-total-moi","dir":"Articles","previous_headings":"Runtime vs number of episodes","what":"Fixed total MOI","title":"Benchmarking Pv3Rs","text":"simulate genetic data consisting one marker (8 alleles), various numbers episodes fixed total MOI seven. See printed output sequence MOIs considered.  total MOI fixed, runtime increase drastically number episodes (note linear scale, log scale). However, episodes still lead valid relationship graphs pairs can clones, explaining increase runtime.","code":"set.seed(1) n_m <- 1 n_a <- 8 maxepi <- 7 # fixed total MOI n_rep <- 30  MOI_fix_comb <- list() for(epi in 2:maxepi) {   m <- maxepi %/% epi   rem <- maxepi %% epi   MOI_fix_comb <- c(MOI_fix_comb, list(c(rep(m+1, rem), rep(m, epi-rem)))) }  data_by_MOI_fix <- list() for (MOIs in MOI_fix_comb) {   data_by_MOI_fix[[paste(MOIs, collapse=\",\")]] <- lapply(     1:n_rep,     function(x) sim_data(MOIs, n_m, n_a)   ) } time_by_MOI_fix <- list() for (MOIs in MOI_fix_comb) {   MOIstr <- paste(MOIs, collapse=\",\")   time_by_MOI_fix[[MOIstr]] <- sapply(     data_by_MOI_fix[[MOIstr]],     function(data) {       tic(\"\")       suppressMessages(compute_posterior(data$y, data$fs))       res <- toc(quiet=TRUE)       res$toc - res$tic     }   ) } min_time <- min(sapply(time_by_MOI_fix, min)) max_time <- max(sapply(time_by_MOI_fix, max))  par(cex=1.0, mar=c(5, 4.5, 2, 1)) plot(   1, 1, type=\"n\",    xlim=c(1.5, maxepi + 0.5),    ylim=c(0, max_time*1.05),   xlab=\"Number of episodes (fixed total MOI)\",   ylab=\"Runtime (s)\", )  for(epi in 2:maxepi) {   points(rep(epi, n_rep), time_by_MOI_fix[[epi-1]], pch=20) }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/benchmark.html","id":"appendix","dir":"Articles","previous_headings":"","what":"Appendix","title":"Benchmarking Pv3Rs","text":"derive formula RnR_n, number relationship graphs nn episodes one genotype per episode, treat relationship graph nested partition. clonal relationships relationship graph induce partition genotypes subsets, genotypes within subset clones . call subset `clonal cell’. sibling relationships relationship graph induce partition clonal cells subsets, two genotypes subset clones must siblings. Recall Stirling numbers second kind S(n,k)S(n,k) count number ways partition nn objects kk subsets, whereas Bell numbers BkB_k count number ways partition kk objects (number subsets). Letting kk denote number clonal cells, Rn=∑k=1nS(n,k)Bk.R_n = \\sum_{k=1}^n S(n,k)B_k. establish asymptotics RnR_n, first note Rn≥S(n,n)Bn=BnR_n \\ge S(n,n)B_n = B_n. well known logBn∼nlogn\\log B_n \\sim n\\log n. additionally Rn≤nnR_n \\le n^n, follows logRn∼nlogn\\log R_n \\sim n\\log n. rest appendix devoted proving Rn≤nnR_n \\le n^n indeed true. Let ℋn\\mathcal{H}_n set functions hh map elements {1,…,n}\\{1,\\ldots,n\\} {1,…,n}\\{1,\\ldots,n\\}. Since |ℋn|=nn|\\mathcal{H}_n|=n^n, suffices show injection set relationship graphs (nn genotypes) ℋn\\mathcal{H}_n. Consider following mapping relationship graph function hh: Given relationship graph, label genotypes 11 nn, label clonal cells 11 kk. k′=1,…,kk'=1,\\ldots,k, let ck′c_{k'} denote smallest genotype label clonal cell k′k'. genotype ii clonal cell k′k' ck′c_{k'}, define h()=ck′h()=c_{k'}. remains define values h(c1),…,h(ck)h(c_1),\\ldots,h(c_k). sibling relationships induce partition {1,…,k}\\{1,\\ldots,k\\} subsets clonal cells. Let {x1,…,xm}\\{x_1,\\ldots,x_m\\} subset, 1≤x1≤⋯≤xm≤k1\\le x_1 \\le \\cdots \\le x_m\\le k. m′=1,…,mm'=1,\\ldots,m, define h(cxm′)=cxm′+1h(c_{x_{m'}})=c_{x_{m'+1}}, subscripts xx taken modulo mm. repeat subsets partition induced sibling relationships, completes definition mapping. Informally, select one genotype clonal cell representative. function hh maps non-representative genotypes corresponding representatives, maps representative genotypes representative genotypes, subset induced sibling relationships corresponds cycle induced hh. remains show mapping indeed injection. Consider two different relationship graphs g1g_1 g2g_2, corresponding functions h1h_1 h2h_2 mapping . seek show h1≠h2h_1\\neq h_2. Suppose genotypes ii ′' different relationship g1g_1 g2g_2. suffices consider following two cases: Case 1: Genotypes ii ′' strangers one g1g_1 g2g_2, graph. Given function hh obtained mapping relationship graph genotype jj, let sink(j;h)\\textrm{sink}(j;h) denote set genotype labels appear infinitely many times sequence (j,h(j),h(h(j)),…)(j,h(j),h(h(j)),\\ldots). follows sink(;h)≠sink(′;h)\\textrm{sink}(;h)\\neq \\textrm{sink}(';h) genotypes ii ′' strangers. Therefore, must h1≠h2h_1\\neq h_2. Case 2: Genotypes ii ′' siblings one g1g_1 g2g_2, clones graph. Given function hh obtained mapping relationship graph genotype jj, let sink1(j;h)\\textrm{sink}_1(j;h) genotype label sink(j;h)\\textrm{sink}(j;h) occurs first sequence (j,h(j),h(h(j)),…)(j,h(j),h(h(j)),\\ldots). follows sink1(;h)=sink1(′;h)\\textrm{sink}_1(;h)= \\textrm{sink}_1(';h) genotypes ii ′' clones (=′=', irrelevant). Therefore, must h1≠h2h_1\\neq h_2. completes proof logRn∼nlogn\\log R_n \\sim n\\log n.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"basic-workflow","dir":"Articles","previous_headings":"","what":"Basic workflow","title":"Demonstrate Pv3Rs usage","text":"begin synthetic example three episodes (episode names optional) three markers (marker names obligatory) whose alleles known frequencies, fs.","code":"y <- list(\"Enrolment\" = list(m1 = c('b','c','d'),                                m2 = c('a','b'),                               m3 = c('b','c','d')),           \"Recurrence 1\" = list(m1 = c('b','d'),                                  m2 = c('a'),                                  m3 = c('a','b')),           \"Recurrence 2\" = list(m1 = c('d'),                                  m2 = c('a'),                                  m3 = c('a')))  fs <- list(m1 = c(a = 0.27, b = 0.35, c = 0.18, d = 0.20),            m2 = c(a = 0.78, b = 0.14, c = 0.07, d = 0.01),            m3 = c(a = 0.21, b = 0.45, c = 0.26, d = 0.08))"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"plot-data","dir":"Articles","previous_headings":"Basic workflow","what":"1) Plot data","title":"Demonstrate Pv3Rs usage","text":"plot data using plot_data().  marker, different colours represent different alleles. legend main grid shows per-marker allele frequencies via colour proportions, one row per marker, ordered main grid; e.g., d m2 rare. parsimonious MOI estimates compatible data, 3, 2, 1, computed using determine_MOIs(). total genotype count (sum MOIs) 6. Aside synthetic example, markers quart-allelic, imposing low upper bounds MOI estimates based maximum per-marker allele counts. diverse markers recommended MOI estimation recurrence state inference.","code":"plot_data(ys = list(\"Participant data\" = y), fs = fs)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"compute-recurrence-state-posterior-probabilities","dir":"Articles","previous_headings":"Basic workflow","what":"2) Compute recurrence state posterior probabilities","title":"Demonstrate Pv3Rs usage","text":"bulk computational time lies computing log-likelihoods graphs relationships genotypes. number graphs depends MOIs. default, compute_posterior uses MOI estimates generated determine_MOIs. Aside recommend running compute_posterior() data whose total genotype count (sum MOIs) exceeds eight. said, encoded hard limit. experience, possible, long, generate posterior probabilities using data total genotype count 10; 10, calls compute_posterior() liable cause memory-use problems fail. call compute_posterior() specify prior, default three recurrence states assumed equally likely per recurrence. Posterior probabilities recurrent state sequences (C recrudescence, L relapse, reinfection) stored post$joint. , find likely sequence recurrence states IC posterior probability 0.4568: Per-recurrence posterior probabilities recrudescence C, relapse L, reinfection stored post$marg. refer per-recurrence probabilities marg (shorthand marginal) computed simply summing state sequence probabilities. example, probability L Recurrence 1 sum probabilities LC, LL LI:","code":"post <- compute_posterior(y, fs) #> Number of valid relationship graphs (RGs) is 1315 #> =============================================================================| #> Computing log p(Y|RG) for 1315 RGs #> =============================================================================| #> Finding log-likelihood of each vector of recurrence states #> =============================================================================| sort(post$joint, decreasing = T) #>         IC         LC         IL         LL         II         LI         CC  #> 0.45682305 0.21338194 0.15385932 0.08501504 0.05986209 0.03105856 0.00000000  #>         CL         CI  #> 0.00000000 0.00000000 post$marg #>                     C         L          I #> Recurrence 1 0.000000 0.3294555 0.67054446 #> Recurrence 2 0.670205 0.2388744 0.09092065 post$joint[\"LC\"] + post$joint[\"LL\"] + post$joint[\"LI\"] #>        LC  #> 0.3294555"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"plot-per-recurrence-probabilities","dir":"Articles","previous_headings":"Basic workflow","what":"3) Plot per-recurrence probabilities","title":"Demonstrate Pv3Rs usage","text":"Per-recurrence posterior probabilities plotted simplex using plot_simplex().  point yellow region likely recrudescence posterior probability greater 0.5 (falls bright yellow region); point red region likely reinfection posterior probability greater 0.5 (falls bright red region).","code":"oldpar <- par(no.readonly = TRUE) par(mar = c(0,0,0,0)) plot_simplex(p.coords = rbind(post$marg, Prior = rep(1/3, 3)), pch = 20) par(oldpar)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"exploration-of-relationship-graphs","dir":"Articles","previous_headings":"","what":"Exploration of relationship graphs","title":"Demonstrate Pv3Rs usage","text":"explore relationship graphs (RGs) log-likelihoods, set return.RG return.logp TRUE. recover posterior . compute time longer: compute posterior, summations per-marker allelic assignments equivalent within-episode genotype permutations redundant. , default, compute_posterior() sum , conserving memory compute time. exploitation permutation symmetry requires scheme choose single representative among permutations otherwise equivalent. compute meaningful graph likelihood values (values depend representative-choosing scheme), permutations summed return.logp = TRUE, increasing compute time, especially MOIs large. Also, user-specified MOIs exceed determine_MOIs(), permutations summed representative-choosing scheme complicated. log-likelihood relationship graph returned. plot relationship graph(s) largest likelihood. example, two graphs maximum likelihood; isomorphic within-episode genotype permutations.  Using log likelihoods, can also find equivalence class data probable relationship graphs class summed .  Important considerations maximum-likelihood graph(s) might equivalence class data probable relationship graphs class summed (true example). maximum-likelihood graph(s) might incompatible maximum-posterior state sequence, (true example; recall -likely sequence IC). graphs maximum-likelihood equivalence class might incompatible maximum-posterior state sequence (true example; class largest likelihood contains graphs sibling edges incompatible IC).","code":"post <- compute_posterior(y, fs, return.RG = TRUE, return.logp = TRUE) #> Number of valid relationship graphs (RGs) is 1315 #> =============================================================================| #> Computing log p(Y|RG) for 1315 RGs #> =============================================================================| #> Finding log-likelihood of each vector of recurrence states #> =============================================================================| sort(post$joint, decreasing = T) #>         IC         LC         IL         LL         II         LI         CC  #> 0.45682305 0.21338194 0.15385932 0.08501504 0.05986209 0.03105856 0.00000000  #>         CL         CI  #> 0.00000000 0.00000000 # Extract all log likelihoods llikes <- sapply(post$RGs, function(RG) RG$logp)  # Get maximum log likelihood mllikes <- max(llikes)  # Extract the relationship graphs (RGs) with the maximum log likelihood RGs <- post$RGs[which(abs(llikes - mllikes) < .Machine$double.eps^0.5)]  # Plot RGs with maximum log likelihoods oldpar <- par(no.readonly = TRUE) # Store user's options par(mar = rep(0.1,4), mfrow = c(1,2)) for(i in 1:length(RGs)) {   plot_RG(RG_to_igraph(RGs[[i]], determine_MOIs(y)), vertex.size = 20)   box() }  # Add a legend legend(\"bottomright\", pch = 21,         pt.bg =  RColorBrewer::brewer.pal(n = 8, \"Set2\") [1:length(y)],         bty = \"n\", legend = names(y), title = \"Episode\") par(oldpar) # Restore user's options # In the following code, we place two graphs in the same equivalence class if # they share the same likelihood. This is not ideal (two graphs that are not # isomorphic up to permutation could share the same likelihood), but it works # here: the plot shows only isomorphic graphs within the equivalence class.  sorted_llikes <- sort(llikes, decreasing = T) # Sort log likelihoods adj_equal <- abs(diff(sorted_llikes, lag = 1)) < .Machine$double.eps^0.5 # Find matches decr_idxs <- which(adj_equal == FALSE) # Change points: 2, 8, 14, 20, 32, ... class_sizes <- c(decr_idxs[1], diff(decr_idxs)) # Number of graphs per class  # log likelihood of representative from each 'equivalence class' (EC) llikes_unique <- sorted_llikes[decr_idxs]  # EC likelihood class_ps <- exp(llikes_unique)*class_sizes max_class_p <- which(class_ps == max(class_ps)) # ML EC index  max_idx <- decr_idxs[max_class_p] # Index of last graph in ML EC max_size <- class_sizes[max_class_p] # Number of graphs in ML EC  # Plot all graphs within the ML EC  oldpar <- par(no.readonly = TRUE) # Store user's options par(mar = rep(0.1,4), mfrow = c(3,4)) RG_order <- order(llikes, decreasing = T) # order RGs by logl for(i in (max_idx-max_size+1):max_idx) { # EC consists of the RGs with logl rank 21-32   RG <- post$RGs[[RG_order[i]]]   RG_igraph <- RG_to_igraph(RG, determine_MOIs(y))   plot_RG(RG_igraph, vertex.size = 25, vertex.label = NA)   box() } par(oldpar) # Restore user's options"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/genotyping-errors.html","id":"intro","dir":"Articles","previous_headings":"","what":"Introduction","title":"Understand genotyping errors","text":"Pv3Rs’ statistical model account genotyping errors de novo mutations, can lead misclassification. article, demonstrate primary consequence model misspecifications risk mistaking recrudescence near-certain relapse. Intuitively, caused model’s rigid expectation alleles observed recrudescence episode observed preceding episode. de novo mutations genotyping false positives recrudescence episode lead alleles observed preceding episode, Pv3Rs incorrectly eliminate possibility recrudescence. applies case allele dropouts genotyping false negatives preceding episode. Mistaking recrudescence near-certain relapse inconsequential recrudescence relapse probabilities combined, e.g., estimations radical cure efficacy. Otherwise, care needs taken interpreting near-certain relapse output Pv3Rs, may correspond genuine relapse, recrudescence obscured genotyping errors /de novo mutations. Assuming small error rate given sufficient marker count, two cases can distinguished inspecting proportion mismatched markers — markers incompatible recrudescence allele observed recurrence absent preceding episode. proportion mismatched markers aligns expected error rate, one can consider rerunning Pv3Rs without mismatched markers. genuine relapse, proportion mismatched markers higher. Another consequence genotyping error, specifically false positives, spuriously high multiplicities infection. computational limit total genotype count (recommend running Pv3Rs participant data per-episode multiplicities infection sum nine ), false positives might render recurrences computationally infeasible analysed Pv3Rs. Among computationally feasible, false postives might impact probable recrudescence probable reinfection probabilities different parasite genotype counts induce different posterior bounds states (see Understand graph-prior ramifications).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/genotyping-errors.html","id":"data-simulation","dir":"Articles","previous_headings":"","what":"Data simulation","title":"Understand genotyping errors","text":"Let us generate data based following three relationship graphs, four genotypes g1, g2, g3, g4:  relationship graph consists two parasite genotypes enrolment episode two parasite genotypes recurrence episode. ’ve chosen relationship graphs first relationship graph compatible recrudescence, last relationship graph compatible reinfection. code simulate data based relationship graphs. relationship graph, ten data sets simulated. data set, data 50 octo-allelic markers simulated per genotype. internal function (Pv3Rs:::recombine_parent_ids) ensures finite nature parasite genome (accounted Pv3Rs model) captured simulation.","code":"par(mar = c(0, 0.1, 0, 0.1), mfrow = c(1, 3)) suppressMessages(RGs <- enumerate_RGs(c(2, 2))) for(i in c(2, 6, 34)) {   plot_RG(RGs[[i]], vertex.size = 20) } library(gtools) # for `rdirichlet`  N_CHRS <- 14 # P. vivax has 14 chromosomes  # simulate allele frequencies for multiple markers # assumes each marker has the same number of alleles sim_fs <- function(n_m, n_a) {   markers <- paste0(\"m\", 1:n_m) # marker names   n_a_vec <- setNames(rep(n_a, n_m), markers)   lapply(n_a_vec, function(n_a) {     alleles <- letters[1:n_a] # n_a <= 26     fs_unnamed <- as.vector(rdirichlet(1, alpha = rep(1, n_a)))     setNames(fs_unnamed, alleles)   }) }  sim_RG1 <- function(n_m, n_a) {   fs <- sim_fs(n_m, n_a)   init <- lapply(fs, function(f) unique(sample(names(f), 2, TRUE, f)))   return(list(y = list(init = init, recur = init), fs = fs)) }  sim_RG2 <- function(n_m, n_a) {   chrs_per_marker <- ceiling((1:n_m)/(n_m+1)*N_CHRS)   fs <- sim_fs(n_m, n_a)   parents <- lapply(fs, function(f) sample(names(f), 2, TRUE, f))   clone <- lapply(fs, function(f) sample(names(f), 1, prob = f))   sib1 <- Pv3Rs:::recombine_parent_ids(chrs_per_marker)[,1] # full siblings   sib2 <- Pv3Rs:::recombine_parent_ids(chrs_per_marker)[,1] # full siblings   init <- setNames(lapply(1:n_m, function(m) unique(c(parents[[m]][sib1[m]], clone[[m]]))),                    names(fs))   recur <- setNames(lapply(1:n_m, function(m) unique(c(parents[[m]][sib2[m]], clone[[m]]))),                     names(fs))   return(list(y = list(init = init, recur = recur), fs = fs)) }  sim_RG3 <- function(n_m, n_a) {   chrs_per_marker <- ceiling((1:n_m)/(n_m+1)*N_CHRS)   fs <- sim_fs(n_m, n_a)   parents <- lapply(fs, function(f) sample(names(f), 2, TRUE, f))   sib1 <- Pv3Rs:::recombine_parent_ids(chrs_per_marker)[,1] # full siblings   sib2 <- Pv3Rs:::recombine_parent_ids(chrs_per_marker)[,1] # full siblings   init <- setNames(lapply(1:n_m, function(m) unique(parents[[m]][c(sib1[m], sib2[m])])),                    names(fs))   recur <- lapply(fs, function(f) unique(sample(names(f), 2, TRUE, f)))   return(list(y = list(init = init, recur = recur), fs = fs)) }  n_datasets <- 10 # 10 datasets per relationship graph n_m <- 50 # 50 markers n_a <- 8 # 8 possible alleles per marker (same as benchmarking) set.seed(1) datasets_RG1 <- lapply(rep(n_m, n_datasets), sim_RG1, n_a) datasets_RG2 <- lapply(rep(n_m, n_datasets), sim_RG2, n_a) datasets_RG3 <- lapply(rep(n_m, n_datasets), sim_RG3, n_a) all_datasets <- list(datasets_RG1, datasets_RG2, datasets_RG3)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/genotyping-errors.html","id":"pv3rs-on-error-free-data","dir":"Articles","previous_headings":"","what":"Pv3Rs on error-free data","title":"Understand genotyping errors","text":"simulating errors, show output Pv3Rs meets expectations model fit error-free data. error-free case, posterior probabilities concentrate recrudescence, relapse, reinfection three relationship graphs respectively. Note ten points per simplex: one per data set, ten data sets per relationship graph; probabilities per simplex almost identical thus points overlap. physical size plotting marker quantitatively meaningful; role visually distinguish plotting markers later plots.","code":"posts_list <- lapply(all_datasets, lapply,                      function(data) suppressMessages(compute_posterior(data$y, data$fs))) par(mar = c(0, 0.1, 0, 0.1), mfrow = c(1, 3)) for(i in 1:3) {   probs <- do.call(rbind, lapply(posts_list[[i]], function(post) post$marg))   plot_simplex(p.coords = probs, lim.mar = 0.15, p.labels = NA, cex = 2)   if(i == 2) legend(\"top\", pch = 1, pt.cex = 2, bty = \"n\", inset = 0,                      legend = \"Error-free\") }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/genotyping-errors.html","id":"error-simulation","dir":"Articles","previous_headings":"","what":"Error simulation","title":"Understand genotyping errors","text":"Now, introduce errors data. distinguish three types misspecifications: False negatives. genotyping procedure may fail detect alleles, e.g., carried parasites present low densities blood sample. allele dropouts can incorrectly eliminate possibility recrudescence: alleles recrudescence episode may able matched preceding episode suffers false negatives. False negatives can also arise micalls (see ). False positives. refers additional alleles called genotyping procedure truly present. , false positives may incorrectly eliminate possibility recrudescence recurrence suffers false positives. Miscalls. refers mistaking allele another allele. One can view false negative false positive occurring together. De novo mutations can viewed similarly. marker episode, independently modify observed data 2%2\\% probability, using either false negative, false positive, miscall. one allele observed, three misspecifications equal probabilities. Otherwise, avoid missing alleles, false positive miscall simulated equal probability. (Pv3Rs deals well missing alleles: including errors eschewal.) run Pv3Rs modified datasets. predicted, presence errors causes probable recrudescence classified near-certain relapse. (Remember ten probabilities per simplex: one per data set, ten data sets per relationship graph; almost probabilities per simplex thus points overlap.) Also, datasets corresponding third relationship graph reinfection probability overestimated. likely due false positives affecting posterior bounds (see end Introduction).","code":"modify <- function(orig, n_a) {   if(runif(1) < 1/3 && length(orig) > 1) { # false negative     return(sample(orig, length(orig)-1))   }   # both false positive and miscall involve an \"extra\" allele   extra <- sample(setdiff(letters[1:n_a], orig), 1)   if(runif(1) < 1/2) { # false positive     return(unique(c(orig, extra)))   } else { # miscall     return(unique(c(sample(orig, length(orig)-1), extra)))   } }  modified <- list(datasets_RG1, datasets_RG2, datasets_RG3) p.modify <- 0.02 set.seed(2) for(i in 1:3) {   for(j in 1:n_datasets) {     for(k in 1:2) { # episode       for(m in 1:n_m) {         if(runif(1) > p.modify) next         modified[[i]][[j]]$y[[k]][[m]] <- modify(modified[[i]][[j]]$y[[k]][[m]], n_a)       }     }   } }  mposts_list <- lapply(modified, lapply,                      function(data) suppressMessages(compute_posterior(data$y, data$fs))) par(mar = c(0, 0.1, 0, 0.1), mfrow = c(1, 3)) for(i in 1:3) {   probs <- do.call(rbind, lapply(posts_list[[i]], function(post) post$marg))   mprobs <- do.call(rbind, lapply(mposts_list[[i]], function(mpost) mpost$marg))   plot_simplex(p.coords = rbind(probs, mprobs), lim.mar = 0.15, p.labels = NA,                 col = rgb(0, 0, 0, alpha = rep(c(1, 0.3), each = n_datasets)),                cex = rep(c(2, 1), each = n_datasets), pch = rep(c(1, 20), each = n_datasets))   if(i == 2) legend(\"top\", pch = c(1, 20), pt.cex = c(2, 1), bty = \"n\", inset = 0,                      col = rgb(0, 0, 0, alpha = c(1, 0.3)),                     legend = c(\"Error-free\", \"With errors\")) }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/genotyping-errors.html","id":"diagnosis","dir":"Articles","previous_headings":"","what":"Diagnosis","title":"Understand genotyping errors","text":"practical scenario, know underlying relationship graph, distinguish first two simplices posterior probabilities (based data errors) alone, Pv3Rs outputs near-certain relapse. alluded introduction, propose two cases can distinguished simple diagnostic, , proportion mismatched markers. see datasets first relationship graph (corresponding recrudescence error-free data) much lower proportion mismatched markers compared datasets second relationship graph (corresponding relapse error-free data). shows proposed diagnostic promising detecting misclassification recrudescence relapse. Since per marker per episode error rate 2%2\\%, expect ≈4%\\approx 4\\% per marker error rate two episodes, matches empirical proportion mismatched markers first relationship graph. practice, proportion mismatched markers given genuine relapse may follow different distribution depending allele frequencies underlying relationship graph. simulation studies may useful investigating diagnostic behaves beyond scenarios consider .","code":"# count how many markers have some allele in epi1 but not in epi0 count_recru_incompat <- function(epi0, epi1) {   sum(mapply(function(x, y) !all(y %in% x), epi0, epi1)) } incompat_prop_RG1 <- sapply(modified[[1]],                              function(data) count_recru_incompat(data$y$init, data$y$recur)/n_m) incompat_prop_RG2 <- sapply(modified[[2]],                              function(data) count_recru_incompat(data$y$init, data$y$recur)/n_m) breaks <- seq(0, 1, 0.02) h1 <- hist(incompat_prop_RG1, breaks = breaks, plot = FALSE) h2 <- hist(incompat_prop_RG2, breaks = breaks, plot = FALSE) counts <- rbind(h1$counts, h2$counts) barplot(counts, beside = FALSE,         col = c(\"yellow\", \"purple\"),         space = 0,  width = 0.02,         axes = FALSE, offset = 0,         xlab = \"Proportion of mismatched markers\",         ylab = \"Number of datasets (with errors)\") axis(1) axis(2) abline(v = 0.04, col = \"red\", lwd = 3) legend(\"topright\", legend = c(\"First relationship graph\", \"Second relationship graph\", \"Expected error rate\"),        col = c(\"yellow\", \"purple\", \"red\"), pch = \"-\", pt.cex = 4)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/intra-episode-siblings.html","id":"example-of-a-group-of-four-intra-episode-siblings-collapsing-to-two","dir":"Articles","previous_headings":"","what":"Example of a group of four intra-episode siblings collapsing to two","title":"Understand intra-episode siblings","text":"demonstrating intra-episode sibling groups collapse pairs, write function simulate data 200 markers user-specified allelic richness (marker cardinality) enrolment episode comprising stranger plus group four siblings, two one oocyst, two another, drawing two unrelated parental genotypes, recurrence one sibling. Technically, enrolment episode contains five genetically distinct genotypes thus MOI five. However, MOI estimates based maximum per-marker allele counts three one markers polyallelic: two one markers biallelic: Suppose estimate MOIs 3 1 biallelic data using external software exploits heteroallelic marker counts, input external estimates compute_posterior(). Providing data simulated large number markers (200 ), recover almost exactly posterior probabilities using polyallelic data without user-specified MOIs biallelic data user-specified MOIs three one However, following graphs, cliques three intra-episode siblings, zero likelihood given polyallelic data:  Whereas, relationships non-zero likelihood given biallelic data:","code":"simulate_data <- function(marker_cardinality){      # Magic numbers / quantities   set.seed(5) # For reproducibility   n_markers <- 200 # Number of markers   n_strangers <- 3 # Number of stranger parasites   n_oocysts <- 2 # Number of oocysts to draw from      # Derived quantities   alleles <- letters[1:marker_cardinality]   markers <- paste0(\"m\", 1:n_markers) # Marker names      # Uniform allele frequencies    fs <- sapply(markers, simplify = FALSE,                 function(m) setNames(rep(1/marker_cardinality, marker_cardinality), alleles))      # Sample strangers   strangers <- sapply(1:n_strangers, function(i) {     sapply(markers, function(t) sample(names(fs[[t]]), size = 1, prob = fs[[t]]))   })      # Designate strangers   parents <- strangers[, 1:2]      # Map the markers to chromosomes. Assume equally sized chromosomes — reasonable   # if and only if we later assume an equal number of crossovers per chromosome   chrs_per_marker <- round(seq(0.51, 14.5, length.out = n_markers))      # Sample parental allocations dependently per-oocyst    cs <- lapply(1:n_oocysts, function(o) recombine_parent_ids(chrs_per_marker))      # Construct children from parental allocations    all_children <- lapply(1:n_oocysts, function(o) {     oocyst_chidren <- sapply(1:n_markers, function(i) {       sapply(1:ncol(cs[[o]]), function(j) parents[i,cs[[o]][i,j]])     })     colnames(oocyst_chidren) <- markers     return(oocyst_chidren)   })      # Make enrolment infection   enrol <- apply(rbind(all_children[[1]][1:2,],                         all_children[[2]][1:2,],                         strangers[,3]), 2, unique, simplify = F)      # Make paired data   data <- list(enrol = enrol, recur = as.list(all_children[[1]][1,]))      return(list(data = data, fs = fs)) } polyallelic <- simulate_data(10)  determine_MOIs(polyallelic$data) #> [1] 3 1 biallelic <- simulate_data(2)  determine_MOIs(biallelic$data) #> [1] 2 1 ppost <- suppressMessages(compute_posterior(y = polyallelic$data,                                              fs = polyallelic$fs,                                              return.logp = T)) bpost <- suppressMessages(compute_posterior(y = biallelic$data,                                              fs = biallelic$fs,                                              MOIs = c(3,1), return.logp = T))  ppost$marg #>               C         L             I #> recur 0.6666667 0.3333333 2.708985e-116 bpost$marg #>               C         L            I #> recur 0.6666663 0.3333337 4.625927e-18 llikes <- sapply(bpost$RGs, function(RG) RG$logp) # Extract log likelihoods any(is.infinite(llikes)) # Are there any minus infinity log likelihoods? #> [1] FALSE"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/intra-episode-siblings.html","id":"contribution-to-upper-bounds","dir":"Articles","previous_headings":"","what":"Contribution to upper bounds","title":"Understand intra-episode siblings","text":"summation graphs cliques three siblings possibly redundant given graphs practical support. Even graphs zero likelihood, contribute maximum probabilities recrudescence / reinfection conditionally uniform prior graphs. However, upper bounds probability reinfection / recrudescence given single recurrence contribution small, especially reinfection:   recrudescence, 3 MOI vectors (circled plot ) result absolute difference greater 0.0175. feature large MOIs (MOI vectors 5 2 , 6 2 , 7 1 ) thus whose graph spaces include graphs largest cliques intra-episode siblings. contribution likely even smaller vectors three MOIs computationally feasible Pv3Rs, constituent MOIs necessarily less 7 (recall computationally feasible MOI vectors sum eight).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"summary-of-contents","dir":"Articles","previous_headings":"","what":"Summary of contents","title":"Understand posterior probabilities","text":"start documenting output compute_posterior() statistical model underpinning well specified Data missing Data uninformative Data limited one episode Data incomparable across episodes Data limited one marker Data limited two markers Given data many markers, show well specified model maximum probabilities recrudescence reinfection depend Per-episode multiplicities infections Episode count Position recurrence sequence episodes thus comment dependencies impact interpretation uncertainty given probable uncertain recrudescence reinfection. Finally, summarise results output compute_posterior() model misspecified Meiotic siblings Half siblings Parent-child-like siblings detailed results sibling misspecification can found inRelationshipStudy. characterise model misspecification due genotyping errors undetected alleles [ADD LINK]. yet characterised misspecification due stranger parasites elevated relatedness: Stranger parasites related insofar population related average accounted : Allele frequency estimates encode population-level average relatedness locus--locus [Mehra et al. 2025]. Allele frequency estimates plugged statistical model underpinning Pv3Rs. Providing computed sample drawn parasite population trial participants also draw, need compensate population-level average relatedness locus--locus. However, strong inter-locus dependence (linkage disequilibrium) generate overconfident posterior probabilities. Stranger parasites related due population structure (e.g., proximity space time) likely lead misclassification reinfection relapse / recrudescence. view, recurrence classification presence population structure best understood using complementary population-genetic sensitivity analyses (e.g., identity--descent networks).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"missing","dir":"Articles","previous_headings":"","what":"Missing data","title":"Understand posterior probabilities","text":"data entirely missing, compute_posterior() returns prior. data missing user provides MOIs incompatible recrudescence, compute_posterior() returns prior re-weighted exclusion recrudescence.","code":"fs = list(m1 = c(\"A\" = 0.5, \"B\" = 0.5)) # Allele frequencies y = list(enrol = list(m1 = NA), recur = list(m1 = NA)) # Missing data suppressMessages(compute_posterior(y, fs))$marg # Posterior #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333 suppressMessages(compute_posterior(y, fs, MOIs = c(1,2)))$marg  #>       C   L   I #> recur 0 0.5 0.5"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"uniformative","dir":"Articles","previous_headings":"","what":"Uniformative data","title":"Understand posterior probabilities","text":"data uninformative genetic diversity, compute_posterior() returns prior.","code":"fs = list(m1 = c(\"A\" = 1)) # Unit allele frequency: no genetic diversity y = list(list(m1 = \"A\"), recur = list(m1 = \"A\")) # Data the only viable allele suppressMessages(compute_posterior(y, fs))$marg # Posterior #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333"},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"homoallelic-data-without-user-specified-mois-prior-return","dir":"Articles","previous_headings":"Data on only one episode","what":"Homoallelic data without user-specified MOIs: prior return","title":"Understand posterior probabilities","text":"one episode homoallelic data user specify MOI > 1, compute_posterior() returns prior.","code":"fs = list(m1 = c(\"A\" = 0.5, \"B\" = 0.5)) # Allele frequencies y <- list(enrol = list(m1 = NA), recur1 = list(m1 = \"A\")) # No enrolment data suppressMessages(compute_posterior(y, fs))$marg # Posterior #>                C         L         I #> recur1 0.3333333 0.3333333 0.3333333"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"heteroallelic-data-prior-proximity","dir":"Articles","previous_headings":"Data on only one episode","what":"Heteroallelic data: prior proximity","title":"Understand posterior probabilities","text":"one episode heteroallelic data, MOI model necessarily exceeds one model assumes false alleles. posterior close prior equal data slightly informative: relationship graphs intra-episode siblings, heteroallelic data limit summation identity--descent partitions partitions least two cells episode data. lower bound cell count increases number distinct alleles observed.","code":"# Allele frequencies  fs = list(m1 = c('A' = 0.25, 'B' = 0.25, 'C' = 0.25, 'D' = 0.25))   # MOI at enrolment increases with number of observed alleles:   yMOI2 <- list(enrol = list(m1 = c('A','B')), recur = list(m1 = NA)) yMOI3 <- list(enrol = list(m1 = c('A','B','C')), recur = list(m1 = NA)) yMOI4 <- list(enrol = list(m1 = c('A','B','C','D')), recur = list(m1 = NA)) ys <- list(yMOI2, yMOI3, yMOI4) do.call(rbind, lapply(ys, function(y) {   suppressMessages(compute_posterior(y, fs))$marg }))  #>               C         L         I #> recur 0.3292683 0.3414634 0.3292683 #> recur 0.3260870 0.3478261 0.3260870 #> recur 0.3248359 0.3503282 0.3248359  # MOI increases with external input: MOIs <- list(c(2,1), c(2,2), c(3,2)) # user-specified MOIs y <- list(enrol = list(m1 = c('A','B')), recur = list(m1 = NA)) # Data  do.call(rbind, lapply(MOIs, function(x) {   suppressMessages(compute_posterior(y, fs, MOIs = x))$marg }))  #>               C         L         I #> recur 0.3292683 0.3414634 0.3292683 #> recur 0.3250000 0.3500000 0.3250000 #> recur 0.3334508 0.3330983 0.3334508"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"rare-homoallelic-data-with-user-specified-mois-exceeding-1-prior-departure","dir":"Articles","previous_headings":"Data on only one episode","what":"Rare homoallelic data with user-specified MOIs exceeding 1: prior departure","title":"Understand posterior probabilities","text":"data homoallelic, user specifies MOIs greater one, observed allele rare, posterior departs prior rare intra-episode allelic repeats probable given relationship graphs intra-episode relatedness.  per-graph likelihood appreciable relationship graphs distinct parasite genotypes first episode siblings","code":"y <- list(enrol = list(m1 = 'A'), list(m1 = NA)) # Homoallelic data MOIs <- list(c(2,1), c(3,2), c(5,1)) # Different MOIs with first MOI > 1 fs = list(m1 = c(\"A\" = 0.01, \"B\" = 0.99)) # Rare observed allele"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"incomparable","dir":"Articles","previous_headings":"","what":"Data are incomparable across episodes","title":"Understand posterior probabilities","text":"data multiple episodes common markers across episodes, compute_posterior() behaves similarly data limited one episode: returns prior data homoallelic without user-specified MOIs > 1, output remains close prior data heteroallelic, output departs prior data homoallelic rare user-specified MOIs > 1.","code":"# Allele frequencies fs = list(m1 = c(\"A\" = 0.01, \"B\" = 0.99),            m2 = c(\"A\" = 0.01, \"B\" = 0.99))   # Data with an incomparable homoallelic call y_hom <- list(enrol = list(m1 = \"A\", m2 = NA),                recur = list(m1 = NA, m2 = \"A\"))  # Data with an incomparable heteroallelic call y_het <- list(enrol = list(m1 = c(\"A\", \"B\"), m2 = NA),                recur = list(m1 = NA, m2 = c(\"A\", \"B\")))  suppressMessages(compute_posterior(y_hom,fs))$marg # Prior return  #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333 suppressMessages(compute_posterior(y_het,fs))$marg # Prior proximity #>               C         L         I #> recur 0.3370787 0.3595506 0.3033708 suppressMessages(compute_posterior(y_hom,fs,MOIs=c(2,2)))$marg # Prior departure #>               C         L        I #> recur 0.5142862 0.2183909 0.267323"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"one-marker","dir":"Articles","previous_headings":"","what":"Data on only one marker","title":"Understand posterior probabilities","text":"Given data one marker, output compute_posterior() depends observation type frequencies observed alleles: rare match informative: quashes posterior probability reinfection. partial rare match informative: quashes posterior probability reinfection. match common allele informative: states possible posteriori. partial match common allele informative: states possible posteriori. mismatch informative: quashes posterior probability recrudescence. latter demonstrates sensitivity recrudescence inference assumption model genotyping errors: genotyping error generates single mismatch, posterior probability recrudescence quashed.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"two-markers","dir":"Articles","previous_headings":"","what":"Data on only two markers","title":"Understand posterior probabilities","text":"Adding second consistent observation generally strengthens inference (see arrows entering regions probability > 0.5). exception adding common match common partial match, adds little information (central arrow). mismatch added rare match (diamond), relapse becomes probable state. illustrates multiple-marker requirement relapse inference.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"many-markers","dir":"Articles","previous_headings":"","what":"Data on many markers","title":"Understand posterior probabilities","text":"Given non-zero prior probabilities, data increase number markers, posterior probabilities given recurrence well specified model converge either Relapse posterior probability one data suggest episode interest linked previous episodes regular sibling relationships Recrudescence posterior probability less one data suggest episode interest linked directly preceding episode clonal relationships Reinfection posterior probability less one data suggest episode interest linked previous episodes regular sibling clonal relationships Recrudescence / reinfection probabilities necessarily converge uncertain values genetic data compatible recrudescence / reinfection also compatible relapse.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"posterior-bounds","dir":"Articles","previous_headings":"Data on many markers","what":"Posterior bounds","title":"Understand posterior probabilities","text":"assume priori relationship graphs compatible given recurrence state sequence uniformly distributed, relationship graphs compatible sequences recrudescence / reinfection subset compatible sequences relapse, prior-induced bounds non-marginal posterior probabilities can computed priori function prior recurrence state sequences prior relationship graphs; see Understand graph-prior ramifications. probability mass function uniformly distributed discrete random variable depends size support, prior uniformly distributed graphs (resulting prior-induced posterior bounds) depends size graph space. size space determined size graphs contains, many vertices parasite genotypes within across episodes. , graph size depends number episodes per-episode MOIs, vary across trial participants. Using rare matched mismatched data 100 markers, illustrate prior-induced posterior bounds single recurrence depend per-episode MOIs. also demonstrate maximum marginal probabilities recrudescence / relapse depend episode counts adding recurrences recurrent data. However, maxima rely knowing recurrent data absent first recurrence thus computable priori. start defining variables used repeatedly following code chunks.","code":"marker_count <- 100 # Number of markers ms <- paste0(\"m\", 1:marker_count) # Marker names  all_As <- sapply(ms, function(t) \"A\", simplify = F) # As for all markers all_Bs <- sapply(ms, function(t) \"B\", simplify = F) # Bs for all markers no_data <- sapply(ms, function(t) NA, simplify = F) # NAs for all markers fA <- 0.01 # Frequency of rare allele fB <- 1 - fA # Frequency of common allele fs <- sapply(ms, function(m) c(\"A\"=fA, \"B\"=fB), simplify = FALSE) # Frequencies"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"mois","dir":"Articles","previous_headings":"Data on many markers","what":"Increasing per-episode MOIs","title":"Understand posterior probabilities","text":"posterior probabilities increase increasing graph size, MOIs balanced case recrudescence.","code":"MOIs <- list(c(1,1), c(2,1), c(2,2))  y_match <- list(enrol = all_As, recur = all_As) y_mismatch <- list(enrol = all_As, recur = all_Bs)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"digression-counts-of-intra-episode-siblings","dir":"Articles","previous_headings":"Data on many markers > Increasing per-episode MOIs","what":"Digression: counts of intra-episode siblings","title":"Understand posterior probabilities","text":"increase per-episode MOIs, can increase user-specified MOIs without changing data, can increase allelic diversity data, s.t. MOIs modelled Pv3Rs increase without user-specified MOIs. Either way, get maximum probabilitie, graph likelihoods change:  homoallelic data elevated user-specified MOIs, intra-episode parasites maximum likelihood graphs siblings. heteroallelic data, intra-episode parasites maximum likelihood graphs strangers. One upshot maximum probabilities arbitrarily increased increasing counts intra-episode siblings. Since siblings independent, maxima arguably increase beyond two siblings per episode. Pv3Rs model realistic MOI estimates, groups three siblings effectively treated pairs; see Understand intra-episode siblings. END DIGRESSION","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"epi-count","dir":"Articles","previous_headings":"Data on many markers","what":"Increasing episode counts","title":"Understand posterior probabilities","text":"Recurrences can added without adding data marginal probability first recurrence recrudescence / reinfection depends total number recurrences:  example recrudescence probabilities converge maxima 1, 2, 5 100 markers:  Recall maxima bounds imposed prior: based knowledge recurrent data first recurrence; see Understand graph-prior ramifications.","code":"ys_match <- list(\"1_recurrence\" = list(enrol = all_As,                                         recur1 = all_As),                  \"2_recurrence\" = list(enrol = all_As,                                         recur1 = all_As,                                        recur2 = no_data),                  \"3_recurrence\" = list(enrol = all_As,                                         recur1 = all_As,                                        recur2 = no_data,                                        recur3 = no_data))  ys_mismatch <- list(\"1_recurrence\" = list(enrol = all_As,                                            recur1 = all_Bs),                     \"2_recurrence\" = list(enrol = all_As,                                            recur1 = all_Bs,                                           recur2 = no_data),                     \"3_recurrence\" = list(enrol = all_As,                                            recur1 = all_Bs,                                           recur2 = no_data,                                           recur3 = no_data))"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"position","dir":"Articles","previous_headings":"Data on many markers","what":"Position in a sequence","title":"Understand posterior probabilities","text":"distribution relationship graphs invariant different orderings states sequence (graphs compatible reinfection beginning versus end sequence three episodes, example), position recurrence sequence affects per-recurrence posterior probability. examples also highlight , well-specified model, jointly modelling data across two episodes preferable analysing episodes pairwise. effect position negligible episodes data many markers: Instead, consider sequences episodes observations (Os) episodes data (Ns):","code":"y <- list(enrol = all_As,            recur1 = all_As,            recur2 = all_As,            recur3 = all_As) suppressMessages(compute_posterior(y, fs))$marg #>                C         L            I #> recur1 0.7720588 0.2279412 5.585675e-23 #> recur2 0.7720588 0.2279412 5.316220e-23 #> recur3 0.7720588 0.2279412 5.044004e-23 ys_match <- list(\"NOO\" = list(enrol = no_data,                                recur1 = all_As,                               recur2 = all_As),                  \"ONO\" = list(enrol = all_As,                                recur1 = no_data,                               recur2 = all_As),                  \"OON\" = list(enrol = all_As,                                recur1 = all_As,                               recur2 = no_data))  ys_mismatch <- list(\"NOO\" = list(enrol = no_data,                                   recur1 = all_As,                                  recur2 = all_Bs),                     \"ONO\" = list(enrol = all_As,                                   recur1 = no_data,                                  recur2 = all_Bs),                      \"OON\" = list(enrol = all_As,                                   recur1 = all_Bs,                                  recur2 = no_data))"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"highly-informed-recurrences","dir":"Articles","previous_headings":"Data on many markers > Position in a sequence","what":"Highly informed recurrences","title":"Understand posterior probabilities","text":"first recurrence sequence OON (upward purple 1 triangle) slightly lower probability recrudescence second recurrence sequence NOO (upward green 2 triangle) despite recurrences rare observations match directly preceding episode. first recurrence sequence OON (downward purple 1 triangle) slightly higher probability reinfection second recurrence sequence NOO (downward green 2 triangle) despite recurrences observations mismatch directly preceding episode.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"weakly-and-uninformed-recurrences","dir":"Articles","previous_headings":"Data on many markers > Position in a sequence","what":"Weakly and uninformed recurrences","title":"Understand posterior probabilities","text":"Unsurprisingly, posterior first recurrence sequence NOO close prior (preceding data), likewise second recurrence sequence OON (data). surprisingly, posterior first recurrence sequence ONO close prior, despite data. closer inspection, surprising reasons explained . match data (upward triangles), strong evidence clonal edge episodes one three ONO incompatible recurrence sequences ending reinfection reinfection followed recrudescence, informing strongly second recurrence weakly first recurrence. comparison, strong evidence clonal edge episodes two three NOO incompatible sequences recurrences ending reinfection, informing second recurrence ; likewise, strong evidence clonal edge episodes one two OON incompatible sequences recurrences starting reinfection, informing first recurrence . close inspection upward orange 1 triangle makes intuitive sense: know first recurrence followed second MOI = 1 recurrence clone MOI = 1 enrolment episode, unlikely second recurrence clone drawn new mosquito recrudescence reinfection. Thus, enrolment second recurrence data inform first recurrence, causing posterior deviate prior even though data. explanation mismatch data (downward triangles) sequence ONO similar match data: strong evidence stranger edge episodes one three incompatible double recrudescence, posterior first recurrence (downward orange 1 triangle) deviates prior despite first recurrence data.","code":"epsilon <- .Machine$double.eps # Very small probability names(which(suppressMessages(compute_posterior(y = ys_match[[\"ONO\"]], fs))$joint < epsilon)) #> [1] \"IC\" \"CI\" \"LI\" \"II\" names(which(suppressMessages(compute_posterior(y = ys_match[[\"NOO\"]], fs))$joint < epsilon)) #> [1] \"CI\" \"LI\" \"II\" names(which(suppressMessages(compute_posterior(y = ys_match[[\"OON\"]], fs))$joint < epsilon)) #> [1] \"IC\" \"IL\" \"II\" epsilon <- .Machine$double.eps # Very small probability names(which(suppressMessages(compute_posterior(y = ys_mismatch[[\"ONO\"]], fs))$joint < epsilon)) #> [1] \"CC\" names(which(suppressMessages(compute_posterior(y = ys_mismatch[[\"NOO\"]], fs))$joint < epsilon)) #> [1] \"CC\" \"LC\" \"IC\" names(which(suppressMessages(compute_posterior(y = ys_mismatch[[\"OON\"]], fs))$joint < epsilon)) #> [1] \"CC\" \"CL\" \"CI\""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"uncertainty","dir":"Articles","previous_headings":"","what":"Interpreting uncertainty","title":"Understand posterior probabilities","text":"Uncertain posterior probabilities can uncertain two reasons mutually exclusive: data needed states fully identifiable also important bear mind -illustrated facts , Pv3Rs model, trial participants different per-episode MOIs episode counts different maximum probabilities recrudescence / reinfection. example, use common threshold 0.8 classify probable reinfection assuming recurrence states equally likely priori, can discount priori trial participants single monoclonal recurrence following monoclonal enrolment episode posterior reinfection probabilities never exceed 0.75, even data highly informative reinfection: , given trial participant, probability recrudescence / reinfection depends position within sequence, especially one episodes data.","code":"y <- list(enrol = all_As, recur = all_Bs) fs <- sapply(ms, FUN = function(m) c(\"A\" = 0.5, \"B\" = 0.5), simplify = FALSE)  # Using the default uniform prior on recurrence states suppressMessages(compute_posterior(y, fs))$marg #>       C    L    I #> recur 0 0.25 0.75  # Using a non-uniform prior on recurrence states prior <- as.matrix(data.frame(\"C\" = 0.25, \"L\" = 0.25, \"I\" = 0.5)) suppressMessages(compute_posterior(y, fs, prior))$marg #>       C         L         I #> recur 0 0.1428571 0.8571429"},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"methods","dir":"Articles","previous_headings":"Meiotic siblings","what":"Methods","title":"Understand posterior probabilities","text":"simulated data generated results initial infection containing two three meiotic siblings recurrent stranger clone regular sibling meiotic sibling Posterior probabilities computed assuming recurrence states equally likely priori.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"results","dir":"Articles","previous_headings":"Meiotic siblings","what":"Results","title":"Understand posterior probabilities","text":"initial infection contains two meiotic siblings compute_posterior() well behaved maximum likelihood true relationship graph (shown). Posterior probabilities converge probable reinfection recurrent parasite stranger, probable recrudescence recurrent parasite clone, certain relapse recurrent parasite regular sibling, certain relapse recurrent parasite meiotic sibling.  initial infection contains three meiotic siblings recurrent parasite either stranger clone, posterior probabilities converge correctly probable reinfection probable recrudescence, respectively, maximal values given graphs relationships two, three, parasites initial infection.  Relationship graphs (shown) wrong two reasons: relationship graphs two, three, parasites initial infection two alleles per marker. Although technically incorrect, behaviour arguably desirable; see digression section Data many markers. highest likelihood relationship graphs stranger parasites initial episode prevalence data three four meiotic siblings identical bulk data parents, strangers. can force graphs three distinct parasites initial episode specifying external MOIs. recovers maximum likelihood true relationship graphs. However, correct MOIs unknowable practice: collection siblings two parents can ever diverse two parents. initial infection contains three meiotic siblings recurrent parasite regular meiotic sibling, posterior probabilities converge probable recrudescence maximum likelihood graphs clonal edge sibling relapse, either two stranger parasites initial episode external MOIs specified, three sibling parasites initial episode correct MOIs (unknowable practice) provided externally.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"methods-1","dir":"Articles","previous_headings":"Half siblings","what":"Methods","title":"Understand posterior probabilities","text":"simulated data three half siblings: two initial episode, third recurrence: child parents 1 2 initial episode child parents 1 3 initial episode child parents 2 3 recurrence explored two scenarios: one parental parasites draw allele distribution. Another admixture parent 1 draws alleles disproportionally parents 2 3. admixture scenario improbable. explore worse case scenario: contrived maximally hamper relapse classification.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"results-1","dir":"Articles","previous_headings":"Half siblings","what":"Results","title":"Understand posterior probabilities","text":"general, parental parasites draw allele distribution, frequency certain relapse increases erratically number markers genotyped. particular case three equifrequent alleles per marker, can show theoretically system behaves erratically small perturbation ratio observations (alleles match across three half siblings, alleles different, intra-episode alleles match, inter-episode alleles match) can lead large deviation odds relapse versus reinfection; see Understand half-sibling misspecification. purple, red, green trajectories higher expected 0.5 intra--inter match ratios; moreover, purple trajectory’s intra--inter match ratio consistently exceeds 0.5×log2(25)0.5\\times \\text{log}_2(\\dfrac{2}{5}), condition found theoretically concentrate posterior probability reinfection certain conditions; , see Understand half-sibling misspecification. intra-episode parasites systematically share rare alleles (admixture imbalanced allele frequencies), frequency probable reinfection increases erratically number markers genotyped. scenarios, likelihood true graph siblings within across episodes quashed soon distinct alleles three parents observed given marker. general, parasites draw allele distribution, maximum likelihood graphs two one inter-episode sibling edge. intra-episode parasites systematically share rare alleles, maximum likelihood graph one one intra-episode sibling edge.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"methods-2","dir":"Articles","previous_headings":"Parent-child-like siblings","what":"Methods","title":"Understand posterior probabilities","text":"simulated data three parent-child-like siblings: child selfed parent 1 initial episode child parents 1 2 initial episode child selfed parent 2 recurrence Aside: alternative children selfed parents initial episode equivalent meiotic case three mieotic siblings initial episode prevalence data three meiotic siblings equivalent prevalence data two stranger parents leads probable recrudescence rather certain relapse number markers genotyped. half-siblings, explored two scenarios: one parental parasites draw allele distribution. Another admixture parent 1 draws alleles disproportionally parent 2. admixture scenario improbable. explore worse case scenario: contrived maximally hamper relapse classification.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"results-2","dir":"Articles","previous_headings":"Parent-child-like siblings","what":"Results","title":"Understand posterior probabilities","text":"parental parasites draw allele distribution, frequency certain relapse increases erratically number markers genotyped.  intra-episode parasites systematically share rare alleles (admixture imbalanced allele frequencies), frequency probable reinfection increases erratically number markers genotyped.  general, parasites draw allele distribution, maximum likelihood graph true graph siblings within across episodes. Meanwhile, intra-episode parasites systematically share rare alleles, maximum likelihood graph one one intra-episode sibling edge.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Aimee Taylor. Author, maintainer. Yong See Foo. Author. Tymoteusz Kwiecinski. Compiler.           compiled included macros.Rd Duncan Murdoch. Contributor.           author included macros.Rd Mans Magnusson. Contributor.           author included msg_progress_bar.R Institut Pasteur. Copyright holder. European Union, Project 101110393. Funder.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Taylor , Foo Y (2025). Pv3Rs: Estimate Cause Recurrent Vivax Malaria using Genetic Data. R package version 0.0.2.9000, https://aimeertaylor.github.io/Pv3Rs/.","code":"@Manual{,   title = {Pv3Rs: Estimate the Cause of Recurrent Vivax Malaria using Genetic Data},   author = {Aimee Taylor and Yong See Foo},   year = {2025},   note = {R package version 0.0.2.9000},   url = {https://aimeertaylor.github.io/Pv3Rs/}, }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"pv3rs-","dir":"","previous_headings":"","what":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"R package Plasmodium vivax molecular correction via statistical genetic inference Relapse Recrudescence Reinfection core function, compute_posterior(), computes per-person posterior probabilities relapse, recrudescence, reinfection (recurrence states) using P. vivax genetic data two episodes. better understand core function, addition README, recommend reading - documentation accessed via ?compute_posterior() - vignette “Demonstrate Pv3Rs usage” accessed via vignette(\"demonstrate-usage\", \"Pv3Rs\") - Understand posterior probabilities - article “Pv3Rs: Plasmodium vivax relapse, recrudescence, reinfection statistical genetic inference” published Bioinformatics Two important features: plot_data() visualises genetic data molecular correction, regardless analytical method (e.g., can used visualise Plasmodium falciparum data intended analysis using match-counting algorithm). plot_simplex() can used visualise per-recurrence probabilities relapse, recrudescence, reinfection (probability triplet summing one).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"please-be-aware-of-the-following-points","dir":"","previous_headings":"","what":"Please be aware of the following points!","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"statistical model described supplement Bioinformatics article “Pv3Rs: Plasmodium vivax relapse, recrudescence, reinfection statistical genetic inference”. builds prototype features Taylor & Watson et al. 2019.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"prior-considerations","dir":"","previous_headings":"Please be aware of the following points!","what":"Prior considerations:","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Genetic data modelled using Bayesian model, whose prior ideally informative (Taylor & Watson et al. 2019 priors generated time--event model built James Watson) cause recurrent P. vivax malaria always identifiable genetic data alone: data consistent recurrent parasites relatively unrelated preceding infections, reinfection relapse plausible; meanwhile, data compatible recurrent parasites clones preceding infection, recrudescence relapse plausible. main Pv3Rs function, compute_posterior(), applied P. falciparum setting prior probability relapse zero, genotyping errors, accounted current Pv3Rs model, liable lead misclassification recrudescence reinfection prior probability relapse zero (recrudescence relapse prior probability relapse exceeds zero). post hoc diagnostic identify misclassified recrudescence presented Understand genotyping errors.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"notable-assumptions-and-limitations","dir":"","previous_headings":"Please be aware of the following points!","what":"Notable assumptions and limitations:","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"model, Pv3Rs makes various assumptions limit capabilities settings.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"mutually-exclusive-recurrent-states","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Mutually exclusive recurrent states","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Recurrence states modelled mutually exclusive, suitable studies participants actively followed frequently detected infections treated extent parasitaemia drops detectable level recurrence occurs. studies untreated accumulated infections, outputs may meaningful.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"unmodelled-complexities","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Unmodelled complexities","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"model complexities around molecular correction. example, population structure, including household effects; failure capture low-density clones blood sample limited volume [Snounou & Beck, 1998]; hidden biomass spleen bone marrow [Markus, 2019]. Users must interpret outputs light limitations context study methods. example, expect Pv3Rs output probable relapse person reinfected new mosquito parasites recently related caused previous infection, might happen household transmission chains.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"sibling-misspecification","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Sibling misspecification","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Relapsing parasites siblings parasites previous infections can meiotic, parent-child-like, regular half siblings, model sibling parasites regular siblings via following assumptions: Allele inheritance independent (true meiotic siblings, complements one another) Sibling relationships transitive (true parent-child-like trios half-sibling trios) Alleles sibling cluster drawn two parental alleles (true half siblings) experience, half sibling misspecification leads misclassification relapses reinfections; see Understand half-sibling misspecification Understand posterior probabilities, half siblings lead probabilities behaviour erratically increasing marker counts. descriptive study explore extent half-sibling misspecification recommended.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"genotyping-errors-and-de-novo-mutations","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Genotyping errors and de novo mutations","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"model undetected alleles, genotyping errors, de novo mutations. Recrudescent parasites modelled perfect clones Pv3Rs. , posterior probability recrudescence rendered zero errors mutations. becomes likely data markers. Understand genotyping errors explores impact errors mutations recurrence state probabilities.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"interpreting-probable-reinfection-and-recrudescence","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Interpreting probable reinfection and recrudescence","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"genetic data alone insufficient distinguish recrudescence relapse (reinfection relapse), posterior probabilities recrudescence relapse (reinfection relapse) heavily influenced priori uniform assumption relationship graphs; see Understand graph-prior ramifications. development biologically-principled generative model parasite relationships merited.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"computational-limits","dir":"","previous_headings":"Please be aware of the following points!","what":"Computational limits:","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Pv3Rs scales hundreds markers whole-genome sequence (WGS) data. recommend running compute_posterior() data whose total genotype count (sum per-episode multiplicities infection) exceeds eight. total genotype count exceeds eight multiple recurrences, might possible compute posterior probabilities analysing episodes pairwise (approach used Taylor & Watson et al. 2019; ’re working currently improved version). per-marker allele limit compute_posterior() untested. high marker cardinalities lead small allele frequencies thus underflow problems.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"population-level-allele-frequencies","dir":"","previous_headings":"Please be aware of the following points!","what":"Population-level allele frequencies:","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"addition P. vivax allelic data two episodes, compute_posterior() requires input population-level allele frequencies. minimise bias due within-host selection recrudescent parasites, recommend using enrolment episodes estimate population-level allele frequencies, ideally enrolment episodes study participants selected random, study participants experience recurrence. said, strong prior reason believe recurrences either reinfections relapses, draws mosquito population (albeit delayed draw case relapse), assuming systematic within-patient selection (might occur infections encounter lingering drug pressure), estimates based episodes unbiased precise based enrolment episodes .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"read-count-data","dir":"","previous_headings":"Please be aware of the following points!","what":"Read-count data:","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Unfortunately, Pv3Rs model exploit data read counts present. However, read-count data used compute population-level allele frequencies, assuming biased experimental artefacts.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"","code":"# Install Pv3Rs from CRAN: install.packages(\"Pv3Rs\")  # Load and attach Pv3Rs library(Pv3Rs)  # List links to all available documentation help(package = \"Pv3Rs\")  # List links to vignettes vignette(package = \"Pv3Rs\")  # View function documentation including examples, e.g.,  ?compute_posterior  #=============================================================================== # To install the development version of Pv3Rs: #=============================================================================== # Doing this in RStudio ensures pandoc, required for vignette building, is # installed. If you're not working in RStudio, you might need to install pandoc  # and check its path (or set build_vignettes = FALSE) install.packages(\"devtools\") # Install or update devtools from CRAN devtools::install_github(\"aimeertaylor/Pv3Rs\", build_vignettes = TRUE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/Pv3Rs-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Pv3Rs: Estimate the Cause of Recurrent Vivax Malaria using Genetic Data — Pv3Rs-package","title":"Pv3Rs: Estimate the Cause of Recurrent Vivax Malaria using Genetic Data — Pv3Rs-package","text":"Plot malaria parasite genetic data two episodes. Compute per-person posterior probabilities Plasmodium vivax (Pv) recurrence recrudescence, relapse, reinfection (3Rs) using per-person P. vivax genetic data two episodes statistical model described Taylor, Foo White (2022) doi:10.1101/2022.11.23.22282669 . Plot per-recurrence posterior probabilities.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/Pv3Rs-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pv3Rs: Estimate the Cause of Recurrent Vivax Malaria using Genetic Data — Pv3Rs-package","text":"Maintainer: Aimee Taylor aimee.taylor@pasteur.fr (ORCID) Authors: Yong See Foo (ORCID) contributors: Tymoteusz Kwiecinski (compiled included macros.Rd) [compiler] Duncan Murdoch (author included macros.Rd) [contributor] Mans Magnusson (author included msg_progress_bar.R) [contributor] Institut Pasteur [copyright holder] European Union, Project 101110393 [funder]","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"Converts RG encoded list igraph object, requires memory allocation can plotted using plot_RG.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"","code":"RG_to_igraph(RG, MOIs)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"RG List encoding RG; see Value enumerate_RGs igraph = FALSE. MOIs Vector per-episode multiplicities infection (MOIs), .e., numbers per-episode genotypes / vertices; adds graph attribute used plot_RG group genotypes / vertices episode.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"weighted graph whose edge weights 1 0.5 encode clonal sibling relationships, respectively.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"","code":"MOIs <- c(3,2) set.seed(6) RG_as_list <- sample_RG(MOIs, igraph = FALSE) RG_as_igraph <- RG_to_igraph(RG_as_list,  MOIs)  # RG encoded as a list requires less memory allocation utils::object.size(RG_as_list) #> 2512 bytes utils::object.size(RG_as_igraph) #> 4568 bytes  # RG encoded as an igraph object can be plotted using plot_RG() and # manipulated using igraph functions plot_RG(RG_as_igraph, margin = rep(0,4), vertex.label = NA)   # Edge weights 1 and 0.5 encode clonal and sibling relationships igraph::E(RG_as_igraph)$weight #> [1] 0.5 0.5 1.0  # Vertex attribute group encodes episode membership igraph::V(RG_as_igraph)$group #> [1] 1 1 1 2 2"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"Computes per-person posterior probabilities P. vivax recurrence states — recrudescence, relapse, reinfection — using per-person genetic data two episodes. usage, see Examples Demonstrate Pv3Rs usage . complete understanding compute_posterior output, see Understand posterior probabilities. Note: progress bar may increment non-uniformly (see Details); may appear stuck computations ongoing.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"","code":"compute_posterior(   y,   fs,   prior = NULL,   MOIs = NULL,   return.RG = FALSE,   return.logp = FALSE,   progress.bar = TRUE )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"y List lists encoding allelic data. outer list contains episodes chronological order. inner list contains named markers per episode. Marker names must consistent across episodes. NA indicates missing marker data; otherwise, specify per-marker vector distinct alleles detected (presently, compute_posterior() support data proportional abundance detected alleles). Repeat alleles NA entries within allelic vectors ignored. Allele names arbitrary, allowing different data types, must correspond frequency names. fs List per-marker allele frequency vectors, names matching marker names y. Per-marker alleles frequencies mut contain one frequency per named allele, names matching alleles y. Per-marker frequencies must sum one. prior Matrix prior probabilities recurrence states per episode, rows episodes chronological order, columns named \"C\", \"L\", \"\" recrudescence, relapse reinfection, respectively. Row names ignored. NULL (default), per-episode recurrence states assumed equally likely priori. MOIs Vector per-episode multiplicities infection (MOIs); Pv3Rs model assumes genotyping errors, MOIs must greater equal parsimonious MOI estimates compatible data; see determine_MOIs(y). estimates used MOIs = NULL (default). return.RG Logical; returns relationship graphs (default FALSE). Automatically set TRUE return.logp = TRUE. return.logp Logical; returns log-likelihood relationship graph (default FALSE). Setting TRUE disables permutation symmetry optimisation thus increases runtime, especially MOIs large. affect output posterior probabilities; example permutation symmetry, see Exploration relationship graphs Demonstrate Pv3Rs usage . progress.bar Logical; show progress bars (default TRUE). Note progress bar may update non-uniformly.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"List containing: marg Matrix marginal posterior probabilities recurrence, rows recurrences columns \"C\" (recrudescence), \"L\" (relapse), \"\" (reinfection). marginal probability sums subset joint probabilities. example, marginal probability \"C\" first two recurrences sums joint probabilities \"CC\", \"CL\", \"CI\". joint Vector joint posterior probabilities recurrence state sequence; within sequence \"C\", \"L\", \"\" used . RGs List lists encoding relationship graphs; returned return.RG = TRUE (default FALSE), log-likelihoods return.logp = TRUE (default FALSE). relationship graph encoded list can converted igraph object using RG_to_igraph thus plotted using plot_RG. details relationship graphs, see enumerate_RGs.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"compute_posterior() computes posterior probabilities proportional likelihood multiplied prior. likelihood sums : ways phase allelic data onto haploid genotypes graphs relationships haploid genotypes ways partition alleles clusters identity--descent enumerate possible relationship graphs haploid genotypes, pairs genotypes can either clones, siblings, strangers. likelihood sequence recurrence states can determined likelihood relationship graphs compatible said sequence. details enumeration relationship graphs can found enumerate_RGs. relationship graph, model sums possible identity--descent partitions. graphs compatible partitions others, log p(Y|RG) progress bar may advance non-uniformly. recommend running `compute_posterior() total genotype count (sum MOIs) exceeds eight many relationship graphs. Notable model assumptions limitations: siblings regular siblings Recrudescent parasites derive immediately preceding episode Recrudescence, relapse reinfection mutually exclusive Undetected alleles, genotyping errors, de novo mutations modelled Population structure various complexities confound molecular correction modelled","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"","code":"# Running example (runs across compute_posterior, plot_data and plot_simplex) # based on real data from chloroquine-treated participant 52 of the Vivax # History Trial (Chu et al. 2018a, https://doi.org/10.1093/cid/ciy319) y <- ys_VHX_BPD[[\"VHX_52\"]] # y is a list of length two (two episodes) compute_posterior(y, fs_VHX_BPD, progress.bar = FALSE) #> Number of valid relationship graphs (RGs) is 971 #> Computing log p(Y|RG) for 971 RGs #> Finding log-likelihood of each vector of recurrence states #>  #> $marg #>   C L           I #> 2 0 1 3.61674e-14 #>  #> $joint #>           C           L           I  #> 0.00000e+00 1.00000e+00 3.61674e-14  #>    # Numerically named alleles y <- list(enrol = list(m1 = c('3','2'), m2 = c('1','2')),           recur1 = list(m1 = c('1','4'), m2 = c('1')),           recur2 = list(m1 = c('1'), m2 = NA)) fs <- list(m1 = c('1' = 0.78, '2' = 0.14, '3' = 0.07, '4' = 0.01),            m2 = c('1' = 0.27, '2' = 0.73)) compute_posterior(y, fs, progress.bar = FALSE) #> Number of valid relationship graphs (RGs) is 250 #> Computing log p(Y|RG) for 250 RGs #> Finding log-likelihood of each vector of recurrence states #>  #> $marg #>                C         L         I #> recur1 0.0000000 0.1949556 0.8050444 #> recur2 0.2938829 0.2476598 0.4584573 #>  #> $joint #>         CC         LC         IC         CL         LL         IL         CI  #> 0.00000000 0.05539481 0.23848807 0.00000000 0.05314490 0.19451493 0.00000000  #>         LI         II  #> 0.08641590 0.37204139  #>    # Arbitrarily named alleles, plotting per-recurrence posteriors y <- list(enrolment = list(marker1 = c(\"Tinky Winky\", \"Dipsy\"),                           marker2 = c(\"Tinky Winky\", \"Laa-Laa\", \"Po\")),           recurrence = list(marker1 = \"Tinky Winky\",                           marker2 = \"Laa-Laa\")) fs <- list(marker1 = c(\"Tinky Winky\" = 0.4, \"Dipsy\" = 0.6),            marker2 = c(\"Tinky Winky\" = 0.1, \"Laa-Laa\" = 0.1, \"Po\" = 0.8)) plot_simplex(p.coords = compute_posterior(y, fs, progress.bar = FALSE)$marg) #> Number of valid relationship graphs (RGs) is 30 #> Computing log p(Y|RG) for 30 RGs #> Finding log-likelihood of each vector of recurrence states #>     # Episode names are cosmetic: \"r1_prior\" is returned for \"r2\" y <- list(enrol = list(m1 = NA), r2 = list(m1 = NA), r1 = list(m1 = NA)) prior <- matrix(c(0.6,0.7,0.2,0.3,0.2,0), ncol = 3,                 dimnames = list(c(\"r1_prior\", \"r2_prior\"), c(\"C\", \"L\", \"I\"))) suppressMessages(compute_posterior(y, fs = list(m1 = c(a = 1)), prior))$marg #> Warning: Data and prior episode names disagree #> Warning: Marker m1 has data on fewer than two episodes #> Warning: Episodes enrol & r2 & r1 have no data #>      C   L   I #> r2 0.6 0.2 0.2 #> r1 0.7 0.3 0.0 prior #>            C   L   I #> r1_prior 0.6 0.2 0.2 #> r2_prior 0.7 0.3 0.0   # Prior is returned when all data are missing y_missing <- list(enrol = list(m1 = NA), recur = list(m1 = NA)) suppressMessages(compute_posterior(y_missing, fs = list(m1 = c(\"A\" = 1)))) #> Warning: Marker m1 has data on fewer than two episodes #> Warning: Episodes enrol & recur have no data #> $marg #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333 #>  #> $joint #>         C         L         I  #> 0.3333333 0.3333333 0.3333333  #>    # Return of the prior re-weighted to the exclusion of recrudescence: suppressMessages(compute_posterior(y_missing, fs = list(m1 = c(\"A\" = 1)),                  MOIs = c(1,2))) #> Warning: Marker m1 has data on fewer than two episodes #> Warning: Episodes enrol & recur have no data #> $marg #>       C   L   I #> recur 0 0.5 0.5 #>  #> $joint #>   C   L   I  #> 0.0 0.5 0.5  #>  # (Recrudescing parasites are clones of previous blood-stage parasites. The # Pv3R model assumes no within-host de-novo mutations and perfect allele # detection. As such, recrudescence is incompatible with an MOI increase on # the preceding infection.)   # Beware provision of unpaired data: the prior is not necessarily returned; # for more details, see link above to \"Understand posterior estimates\" y <- list(list(m1 = c('1', '2')), list(m1 = NA)) fs <- list(m1 = c('1' = 0.5, '2' = 0.5)) suppressMessages(compute_posterior(y, fs))$marg #> Warning: Marker m1 has data on fewer than two episodes #> Warning:  #>              C         L         I #> [1,] 0.3292683 0.3414634 0.3292683"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine multiplicities of infection (MOIs) — determine_MOIs","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"Returns MOI estimate episode based allelic diversity across markers.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"","code":"determine_MOIs(y, return.names = FALSE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"y List lists encoding allelic data; see compute_posterior details. outer list contains episodes chronological order. inner list contains named markers per episode. marker, one must specify allelic vector: set distinct alleles detected marker; NA marker data missing. return.names Logical; TRUE y named episodes, episode names returned.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"Numeric vector containing one MOI estimate per episode, estimate representing maximum number distinct alleles observed marker per episode.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"true MOI number genetically distinct groups clonal parasites within infection. Give take de novo mutations, parasites within clonal group share DNA sequence, call genotype. , MOIs distinct parasite genotype counts. Pv3Rs model assumption genotyping errors, true MOI episode greater equal maximum distinct allele count marker data episode. words, assumption genotyping errors, maximum distinct allelic counts parsimonious MOI estimates compatible data. default, MOI estimates used compute_posterior.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"","code":"y <- list(enrol = list(m1 = c(\"A\", \"B\"), m2 = c(\"A\"), m3 = c(\"C\")),           recur = list(m1 = c(\"B\"), m2 = c(\"B\", \"C\"), m3 = c(\"A\", \"B\", \"C\"))) determine_MOIs(y) # returns c(2, 3) #> [1] 2 3"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":null,"dir":"Reference","previous_headings":"","what":"Enumerate relationship graphs (RGs) — enumerate_RGs","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"RG graph per-person parasite genotypes (vertex), edges clone sibling genotypes. Valid RGs satisfy: Subgraphs induced clone edges cluster graphs. Subgraphs induced clone plus sibling edges cluster graphs. Clone edges link genotypes different episodes.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"","code":"enumerate_RGs(MOIs, igraph = TRUE, progress.bar = TRUE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"MOIs Vector per-episode multiplicities infection (MOIs), .e., numbers per-episode genotypes / vertices. igraph Logical; returns RGs igraph objects (default TRUE). progress.bar Logical; show progress bar (default TRUE).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"list RGs. igraph = FALSE, RG list length four : clone List vectors encoding genotypes per clonal cell. clone.vec Numeric vector clonal cell membership genotype. sib List vectors encoding clonal cells per sibling cell. sib.vec Numeric vector sibling cell membership clonal cell. igraph = TRUE (default), RG encoded igraph object (see RG_to_igraph).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"RGs generated enumerating nested set partitions specific constraints; see Understand graph partition enumeration. nested set parition RG. Clone edges induce cluster graph, equivalent partition genotypes, intra-episode clones allowed. Sibling edges refine clone partition, constraints (intra-episode siblings allowed). nested set partition encoded list. partition represented list vectors (either clone sib) membership vector (either clone.vec sib.vec). default, RG encoded list converted igraph object.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"","code":"graphs <- enumerate_RGs(c(2, 1, 2), progress.bar = FALSE) # nine graphs #> Number of valid relationship graphs (RGs) is 250"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":null,"dir":"Reference","previous_headings":"","what":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"posterior mean multinomial-Dirichlet model uniform prior fit data allele prevalence initial episodes ys_VHX_BPD. model fit allele prevalence (observed) allele frequency ( requires integrating-unknown multiplicities infection) liable underestimate frequencies common alleles overestimate rare detected alleles.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"","code":"fs_VHX_BPD"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"list nine markers; marker named vector allele frequencies sum one.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"MS_data_PooledAnalysis.RData downloaded https://zenodo.org/records/3368828 https://github.com/aimeertaylor/Pv3Rs/blob/main/data-raw/fs_VHX_BPD.R","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a relationship graph (RG) — plot_RG","title":"Plot a relationship graph (RG) — plot_RG","text":"function wrapper around plot.igraph, written group parasite genotypes episode spatially using vertex colour (specifically, parasite genotypes within episodes vertically distributed horizontal jitter layout..group = TRUE (default), equicolored), ensure clone sibling edges plotted using different line types.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a relationship graph (RG) — plot_RG","text":"","code":"plot_RG(   RG,   layout.by.group = TRUE,   vertex.palette = \"Set2\",   edge.lty = c(sibling = \"dashed\", clone = \"solid\"),   edge.col = c(sibling = \"black\", clone = \"black\"),   edge.width = 1.5,   ... )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a relationship graph (RG) — plot_RG","text":"RG igraph object encoding RG; see RG_to_igraph. layout..group Logical; TRUE (default) overrides default layout plot.igraph vertices represent parasite genotypes different episodes distributed horizontally vertices represent genotypes within episodes distributed vertically. vertex.palette character string specifying RColorBrewer palette. Overrides default palette plot.igraph. edge.lty Named vector edge line types corresponding different relationships. edge.col Named vector edge colours corresponding different relationships. edge.width Overrides default edge.width plot.igraph. ... Additional arguments pass plot.igraph, e.g., edge.curved.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a relationship graph (RG) — plot_RG","text":"None","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot a relationship graph (RG) — plot_RG","text":"see plot relationship graphs outputted compute_posterior, please refer Exploration relationship graphs Demonstrate Pv3Rs usage .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"provenance","dir":"Reference","previous_headings":"","what":"Provenance","title":"Plot a relationship graph (RG) — plot_RG","text":"function adapted plot_Vivax_model https://github.com/jwatowatson/RecurrentVivax/blob/master/Genetic_Model/iGraph_functions.R.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a relationship graph (RG) — plot_RG","text":"","code":"RGs <- enumerate_RGs(c(2, 1, 1), progress.bar = FALSE) #> Number of valid relationship graphs (RGs) is 48 oldpar <- par(no.readonly = TRUE) # record user's options par(mfrow = c(3, 4), mar = c(0.1, 0.1, 0.1, 0.1)) for (i in 12:23) {   plot_RG(RGs[[i]],   edge.col = c(sibling = \"gray\", clone = \"black\"),   edge.lty = c(sibling = \"dotted\", clone = \"solid\"),   edge.curved = 0.1)   box() }  par(oldpar) # restore user's options"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots the data — plot_data","title":"Plots the data — plot_data","text":"Plots allelic data grid coloured rectangles.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots the data — plot_data","text":"","code":"plot_data(   ys,   fs = NULL,   person.vert = FALSE,   mar = c(1.5, 3.5, 1.5, 1),   gridlines = TRUE,   palette = RColorBrewer::brewer.pal(12, \"Paired\"),   marker.annotate = TRUE,   legend.lab = \"Allele frequencies\",   legend.line = 0.2,   legend.ylim = c(0.05, 0.2),   cex.maj = 0.7,   cex.min = 0.5,   cex.text = 0.5,   x.line = 0.2,   y.line = 2.5 )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots the data — plot_data","text":"ys Nested list per-person, per-episode, per-marker allelic data; see Examples compute_posterior() expected per-person structure. fs per-marker list numeric vectors allele frequencies. NULL (default), alleles present ys shown legend, per-marker alleles represented equally. colour scheme adaptive, allele may different colours given different ys. fs specified, alleles fs feature legend areas proportional allele frequencies, common alleles occupy larger areas rarer alleles. Specify fs fix allele colour scheme across plots different ys. person.vert Logical. TRUE (default), person IDs printed vertically; otherwise, printed horizontally. mar Vector numbers lines margin main plot; see mar entry par. gridlines Logical. true (default), white grid lines separating people markers drawn. palette Colour palette alleles, see Value section brewer.pal. Generally, colours interpolated: marker d possible alleles, colours used 1/(d+1), ..., d/(d+1) quantiles palette ensure markers different allele counts use different colours. marker.annotate Logical. true (default), names alleles printed top colours legend. legend.lab Label axis legend. Defaults \"Allele frequencies\". Set NA omit label; , consider adjusting legend.ylim use plotting space. legend.line Distance (character heights) colour bar legend label (defaults 1.5). legend.ylim Vector specifying y-coordinate limits legend device coordinates (0 1). Defaults c(0.05, 0.2). cex.maj Numeric; font scaling major axis labels. cex.min Numeric; font scaling minor axis labels. cex.text Numeric; font scaling allele labels. x.line Distance top x-axis x-axis label, defaults 0.2. y.line Distance left y-axis y-axis label, defaults 2.5.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots the data — plot_data","text":"None","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plots the data — plot_data","text":"function plots alleles (colours), observed different episodes (columns), different markers (rows), episodes grouped person. Per-person episodes plotted left right chronological order. multiple alleles detected marker within episode, corresponding grid element subdivided vertically different colours. default, markers ordered lexicographically. fs provided, markers ordered match order within fs. legend depicts alleles marker vertical order main plot. default colour scheme adaptive, designed visually differentiate alleles clearly possible maximizing hue contrast within qualitative palette. Interpolation used make different colour palettes markers different numbers possible alleles. names alleles printed top colours marker.annotate set TRUE.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots the data — plot_data","text":"","code":"oldpar <- par(no.readonly = TRUE) # Store user's options before plotting  # Running example (runs across compute_posterior, plot_data and plot_simplex) # based on real data from chloroquine-treated participant 52 of the Vivax # History Trial (Chu et al. 2018a, https://doi.org/10.1093/cid/ciy319) ys <- ys_VHX_BPD[\"VHX_52\"] # ys is a list of length one (one participant) plot_data(ys, fs = fs_VHX_BPD, marker.annotate = FALSE)   # Full data set: mar <- c(2, 3.5, 1.5, 1) # extra vertical margin for vertical person labels plot_data(ys = ys_VHX_BPD, person.vert = TRUE, mar = mar, legend.lab = NA)  plot_data(ys = ys_VHX_BPD, person.vert = TRUE, mar = mar, legend.lab = NA,           fs = fs_VHX_BPD)  plot_data(ys = ys_VHX_BPD, person.vert = TRUE, mar = mar, legend.lab = NA,           fs = fs_VHX_BPD, marker.annotate = FALSE)   # Demonstrating the adaptive nature of the colour scheme: y <- ys_VHX_BPD[\"VHX_52\"] # A single person # Compared to first example, colours now involve only the alleles detected in VHX_52 plot_data(y)   par(oldpar) # Restore user's options"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots a 2D simplex — plot_simplex","title":"Plots a 2D simplex — plot_simplex","text":"Plots 2D simplex (triangle unit sides centered origin) onto per-recurrence posterior probabilities recrudescence, relapse, reinfection (probability triplet summing one) can projected; see project2D() Examples .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots a 2D simplex — plot_simplex","text":"","code":"plot_simplex(   v.labels = c(\"Recrudescence\", \"Relapse\", \"Reinfection\"),   v.cutoff = 0.5,   v.colours = c(\"yellow\", \"purple\", \"red\"),   plot.tri = TRUE,   lim.mar = 0.1,   p.coords = NULL,   p.labels = rownames(p.coords),   p.labels.pos = 3,   p.labels.cex = 1,   ... )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots a 2D simplex — plot_simplex","text":"v.labels Vertex labels anticlockwise top (default: \"Recrudescence\", \"Relapse\", \"Reinfection\"). NULL, vertices labelled. v.cutoff Number 0.5 1 separates lower vs higher probability regions. Use caution recrudescence reinfection classification; see Understand posterior probabilities. v.colours Vertex colours anticlockwise top. plot.tri Logical; draws triangular boundary TRUE (default). lim.mar Margin away simplex axes limits; defaults 0.1. p.coords Matrix 3D simplex coordinates (e.g., per-recurrence probabilities recrudescence, relapse reinfection), one vector 3D coordinates per row, row projected onto 2D coordinates using project2D() plotted single simplex point using graphics::points(). user provides vector encoding probability triplet summing one, converted matrix one row. p.labels Labels points p.coords (default row names p.coords) labels NA. p.labels.pos Position p.labels: 1 = , 2 = left, 3 = (default) 4 = right. Can single value vector. p.labels.cex Size expansion p.labels passed text. ... Additional parameters passed graphics::points().","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots a 2D simplex — plot_simplex","text":"None","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots a 2D simplex — plot_simplex","text":"","code":"# Running example (runs across compute_posterior, plot_data and plot_simplex) # based on real data from chloroquine-treated participant 52 of the Vivax # History Trial (Chu et al. 2018a, https://doi.org/10.1093/cid/ciy319) y <- ys_VHX_BPD[[\"VHX_52\"]] # y is a list of length two (two episodes) post <- compute_posterior(y, fs_VHX_BPD, progress.bar = FALSE) #> Number of valid relationship graphs (RGs) is 971 #> Computing log p(Y|RG) for 971 RGs #> Finding log-likelihood of each vector of recurrence states #>  plot_simplex(p.coords = post$marg, p.labels = \"\", pch = 20, cex = 2)   # Basic example plot_simplex(p.coords = diag(3),              p.labels = c(\"(1,0,0)\", \"(0,1,0)\", \"(0,0,1)\"),              p.labels.pos = c(1,3,3))   # ============================================================================== # Given data on an enrollment episode and a recurrence, # compute the posterior probabilities of the 3Rs and plot the deviation of the # posterior from the prior # ==============================================================================  # Some data: y <- list(list(m1 = c('a', 'b'), m2 = c('c', 'd')), # Enrollment episode           list(m1 = c('a'), m2 = c('c'))) # Recurrent episode  # Some allele frequencies: fs <- list(m1 = setNames(c(0.4, 0.6), c('a', 'b')),            m2 = setNames(c(0.2, 0.8), c('c', 'd')))  # A vector of prior probabilities: prior <- array(c(0.2, 0.3, 0.5), dim = c(1,3),                dimnames = list(NULL, c(\"C\", \"L\", \"I\")))  # Compute posterior probabilities post <- compute_posterior(y, fs, prior, progress.bar = FALSE) #> Number of valid relationship graphs (RGs) is 9 #> Computing log p(Y|RG) for 9 RGs #> Finding log-likelihood of each vector of recurrence states #>   # Plot simplex with the prior and posterior plot_simplex(p.coords = rbind(prior, post$marg),              p.labels = c(\"Prior\", \"Posterior\"),              pch = 20)  # Add the deviation between the prior and posterior: requires obtaining 2D # coordinates manually xy_prior <- project2D(as.vector(prior)) xy_post <- project2D(as.vector(post$marg)) arrows(x0 = xy_prior[\"x\"], x1 = xy_post[\"x\"],        y0 = xy_prior[\"y\"], y1 = xy_post[\"y\"], length = 0.1)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":null,"dir":"Reference","previous_headings":"","what":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"Project three probabilities sum one (e.g., per-recurrence probabilities recrudescence, relapse reinfection) onto coordinates 2D simplex centred origin (.e., triangle centred (0,0) unit-length sides).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"","code":"project2D(v)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"v numeric vector three numbers zero one sum one.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"numeric vector two coordinates can used plot probability vector v origin-centred 2D simplex.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"top, left, right vertices 2D simplex correspond first, second third entries v, respectively. probability proportional distance point simplex side opposite corresponding probability; see Examples plot_simplex() details.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"","code":"probabilities_of_v1_v2_v3 <- c(0.75,0.20,0.05) coordinates <- project2D(v = probabilities_of_v1_v2_v3)  # Plot probability vector on 2D simplex plot_simplex(v.labels = c(\"v1\", \"v2\", \"v3\")) points(x = coordinates[1], y = coordinates[2], pch = 20)  # Plot the distances that represent probabilities # get vertices, get points on edges by orthogonal projection, plot arrows v <- apply(matrix(c(1,0,0,0,1,0,0,0,1), nrow = 3), 1, project2D) p3 <- v[,1] + sum((coordinates - v[,1]) * (v[,2] - v[,1])) * (v[,2] - v[,1]) p1 <- v[,2] + sum((coordinates - v[,2]) * (v[,3] - v[,2])) * (v[,3] - v[,2]) p2 <- v[,3] + sum((coordinates - v[,3]) * (v[,1] - v[,3])) * (v[,1] - v[,3]) arrows(x0 = coordinates[1], y0 = coordinates[2], x1 = p1[1], y1 = p1[2], length = 0.1) arrows(x0 = coordinates[1], y0 = coordinates[2], x1 = p2[1], y1 = p2[2], length = 0.1) arrows(x0 = coordinates[1], y0 = coordinates[2], x1 = p3[1], y1 = p3[2], length = 0.1)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample a relationship graph (RG) — sample_RG","title":"Sample a relationship graph (RG) — sample_RG","text":"Uses techniques enumerate_RGs sample single RG uniformly. clonal partitions generated, weighted number consistent sibling partitions. clonal partition sampled proportional weight, consistent sibling partition drawn uniformly. resulting nested partition represents RG; see enumerate_RGs details.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample a relationship graph (RG) — sample_RG","text":"","code":"sample_RG(MOIs, igraph = TRUE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample a relationship graph (RG) — sample_RG","text":"MOIs Vector per-episode multiplicities infection (MOIs), .e., numbers per-episode genotypes / vertices. igraph Logical; TRUE (default), returns RG igraph object.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample a relationship graph (RG) — sample_RG","text":"RG encoded either igraph object (default), list; see enumerate_RGs details.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample a relationship graph (RG) — sample_RG","text":"","code":"set.seed(1) RG <- sample_RG(c(3, 2)) plot_RG(RG, vertex.label = NA)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Plasmodium vivax data — ys_VHX_BPD","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"Previously-published microsatellite data P. vivax parasites extracted study participants enrolled Best Primaquine Dose (BPD) Vivax History (VHX) trials; see Taylor & Watson et al. 2019 (doi:10.1038/s41467-019-13412-x ) details genetic data; details VHX BPD trials, see Chu et al. 2018a (doi:10.1093/cid/ciy319 ) Chu et al. 2018b (doi:10.1093/cid/ciy735 ).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"","code":"ys_VHX_BPD"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"list 217 study participants; study participant, list one episodes; episode, list three microsatellite markers; marker, vector observed alleles (repeat lengths). example: BPD_103 Study participant identifier: study participant 103 BPD trial BPD_103_1 Episode identifier: episode one study participant 103 BPD trial PV.3.27 Marker identifier: P. vivax 3.27 18 Allele identifier: 18 repeat lengths","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"MS_data_PooledAnalysis.RData downloaded https://zenodo.org/records/3368828 https://github.com/aimeertaylor/Pv3Rs/blob/main/data-raw/ys_VHX_BPD.R","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/news/index.html","id":"pv3rs-100","dir":"Changelog","previous_headings":"","what":"Pv3Rs 1.0.0","title":"Pv3Rs 1.0.0","text":"CRAN submission post Bioinformatics peer review. README now refers Bioinformatics article “Pv3Rs: Plasmodium vivax relapse, recrudescence, reinfection statistical genetic inference”. License now GPL (>=3) compatibility bundled code macros.Rd. macro written Duncan Murdoch copied rgl package. rgl package GPL-2 | GPL-3 [expanded : GPL] license. Documentation plot_data(), compute_posterior() plot_simplex() now features illustrative example based real data. plot_simplex() now features lim.par control white space around simplex. plot_simplex(), p_coords now p.coords.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/news/index.html","id":"pv3rs-002","dir":"Changelog","previous_headings":"","what":"Pv3Rs 0.0.2","title":"Pv3Rs 0.0.2","text":"CRAN release: 2025-07-31 Users’ par options now restored functions, vignettes examples CRAN re-submission. First attempt failed automatic checks: par preceded graphics:: Second attempt successful.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/news/index.html","id":"pv3rs-001","dir":"Changelog","previous_headings":"","what":"Pv3Rs 0.0.1","title":"Pv3Rs 0.0.1","text":"Initial CRAN submission. Failed manual checks: intra-function use par.","code":""}]
