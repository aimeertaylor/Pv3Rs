[{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Pv3Rs authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"basic-workflow","dir":"Articles","previous_headings":"","what":"Basic workflow","title":"Demonstrate Pv3Rs usage","text":"first look synthetic example three episodes (episode names optional) three markers (marker names obligatory) whose alleles known frequencies. plot data using plot_data().  Different colours plotted data (top) represent different alleles. legend (bottom) shows alleles per marker one row per marker. order markers legend plotted data (see vertical axis, top). allele frequencies specified, widths differently coloured areas legend proportional allele frequencies, s.t. rare alleles relatively small legend areas (e.g., d m2 rare). Aside Given maximum number alleles observed per-episode, parsimonious explanation 3, 2, 1 distinct parasite genotypes three episodes respectively (genotype defined realisation haploid parasite genome; .e., DNA sequence representing group clonal parasites). synthetic example, markers quart-allelic brevity; imposes rather low upper bound MOI estimates based maximum per-marker allele counts. reality, diverse markers recommended recurrence state inference. better MOI estimates available based diverse markers, data diverse markers added data input y compute_posterior(). better MOI estimates based heteroallelic marker counts across many markers available, used recurrence state inference specifying MOI argument function compute_posterior(). Pv3Rs model account genotyping errors, including false positive alleles, user-specified MOIs must greater equal based maximum per-marker allele counts. performing genetic recurrence state inference, bulk computational time lies computing log-likelihoods graphs relationships genotypes. call compute_posterior() specify prior, uniform prior across three recurrence states per recurrence assumed default. Marginal per-recurrence posterior probabilities (probabilities recrudescence C, relapse L, reinfection recurrence) stored post$marg. Per-recurrence posterior probabilities can plotted simplex using function plot_simplex().  point yellow region likely recrudescence posterior probability greater 0.5 (falls bright yellow region); point red region likely reinfection posterior probability greater 0.5 (falls bright red region). Joint posterior probabilities (probabilities chronological sequences recrudescence C, relapse L, reinfection ) stored post$joint. , find likely sequence recurrence states IC posterior probability 0.4568231 Aside: recommend running compute_posterior() data whose total genotype count (sum per-episode MOIs) exceeds eight. said, imposed hard limit code. experience, possible, long, generate estimates using data total genotype count 10 (see code , time 2 seconds); 10 genotypes, calls compute_posterior() liable cause memory-use problems fail.","code":"y <- list(\"Enrolment\" = list(m1 = c('b','c','d'),                                m2 = c('a','b'),                               m3 = c('b','c','d')),           \"Recurrence 1\" = list(m1 = c('b','d'),                                  m2 = c('a'),                                  m3 = c('a','b')),           \"Recurrence 2\" = list(m1 = c('d'),                                  m2 = c('a'),                                  m3 = c('a')))  fs <- list(m1 = c(a = 0.27, b = 0.35, c = 0.18, d = 0.20),            m2 = c(a = 0.78, b = 0.14, c = 0.07, d = 0.01),            m3 = c(a = 0.21, b = 0.45, c = 0.26, d = 0.08)) plot_data(ys = list(\"Participant data\" = y), fs = fs) post <- compute_posterior(y, fs) #> Number of valid relationship graphs (RGs) is 1315 #> =============================================================================| #> Computing log p(Y|RG) for 1315 RGs #> =============================================================================| #> Finding log-likelihood of each vector of recurrence states #> =============================================================================| post$marg #>                     C         L          I #> Recurrence 1 0.000000 0.3294555 0.67054446 #> Recurrence 2 0.670205 0.2388744 0.09092065 # Plot simplex par(mar = rep(0.1,4)) p.coords <- rbind(post$marg, Prior = rep(1/3, 3)) plot_simplex(p.coords = p.coords, pch = 20) sort(post$joint, decreasing = T) #>         IC         LC         IL         LL         II         LI         CC  #> 0.45682305 0.21338194 0.15385932 0.08501504 0.05986209 0.03105856 0.00000000  #>         CL         CI  #> 0.00000000 0.00000000"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"exploration-of-relationship-graphs","dir":"Articles","previous_headings":"","what":"Exploration of relationship graphs","title":"Demonstrate Pv3Rs usage","text":"want explore relationship graphs log likelihoods need set return.RG return.logp TRUE computing posterior; FALSE default. compute posterior, summations per-marker allelic assignments equivalent within-episode genotype permutations redundant. , default, compute_posterior() sum , conserving memory compute time. exploitation permutation symmetry requires scheme choose single representative among permutations otherwise equivalent. user-specified MOIs greater based per-marker allele counts, compute_posterior() sums permutations representative-choosing scheme complicated. Likewise, compute meaningful graph likelihood values (.e., values dependent representative-choosing scheme), permutations summed return.logp = TRUE. increases compute time, especially MOIs large. recover posterior log-likelihood relationship graph also returned output. plot relationship graph(s) largest likelihood.  N.B. two symmetric graphs maximum likelihood: isomorphic within-episode genotype permutations. user note , current example, relationship graph(s) largest likelihood (e.g., ) might equivalence class data probable relationship graphs class summed (e.g., ). following code, place two graphs equivalence class share likelihood. ideal, two graphs isomorphic permutation share likelihood; small number graphs, plots can used check non-isomorphic graphs among placed equivalence class. user also note , maximum-likelihood graph(s) might incompatible maximum-posterior state sequence (albeit true current example: graphs compatible IC) graphs maximum-likelihood equivalence class might incompatible maximum-posterior state sequence (true current example, given class largest likelihood contains graphs sibling edges incompatible IC).","code":"post <- compute_posterior(y, fs, return.RG = TRUE, return.logp = TRUE) #> Number of valid relationship graphs (RGs) is 1315 #> =============================================================================| #> Computing log p(Y|RG) for 1315 RGs #> =============================================================================| #> Finding log-likelihood of each vector of recurrence states #> =============================================================================| sort(post$joint, decreasing = T) #>         IC         LC         IL         LL         II         LI         CC  #> 0.45682305 0.21338194 0.15385932 0.08501504 0.05986209 0.03105856 0.00000000  #>         CL         CI  #> 0.00000000 0.00000000 # Extract all log likelihoods llikes <- sapply(post$RGs, function(RG) RG$logp)  # Extract the relationship graphs (RGs) with the largest log likelihood RGs <- post$RGs[which(abs(llikes - max(llikes)) < .Machine$double.eps^0.5)]  # Plot RG par(mar = rep(0.1,4), mfrow = c(1,2)) for(i in 1:length(RGs)) {   plot_RG(RG_to_igraph(RGs[[i]], determine_MOIs(y)), vertex.size = 20)   box() }  # Generate episode colours in order to add a legend episode_colours <- RColorBrewer::brewer.pal(n = 8, \"Set2\")   # Add a legend legend(\"bottomright\", pch = 21, pt.bg = episode_colours[1:length(y)],         bty = \"n\", legend = names(y), title = \"Episode\") sorted_llikes <- sort(llikes, decreasing = T) # Sort log likelihoods adj_equal <- abs(diff(sorted_llikes, lag = 1)) < .Machine$double.eps^0.5 # Find matches decr_idxs <- which(adj_equal == FALSE) # Change points: 2, 8, 14, 20, 32, ... class_sizes <- c(decr_idxs[1], diff(decr_idxs)) # Number of graphs per class  # log likelihood of representative from each 'equivalence class' (EC) llikes_unique <- sorted_llikes[decr_idxs]  # EC likelihood class_ps <- exp(llikes_unique)*class_sizes max_class_p <- which(class_ps == max(class_ps)) # ML EC index  max_idx <- decr_idxs[max_class_p] # Index of last graph in ML EC max_size <- class_sizes[max_class_p] # Number of graphs in ML EC  # Plot all graphs within the ML EC  par(mar = rep(0.1,4), mfrow = c(3,4)) RG_order <- order(llikes, decreasing = T) # order RGs by logl for(i in (max_idx-max_size+1):max_idx) { # EC consists of the RGs with logl rank 21-32   RG <- post$RGs[[RG_order[i]]]   RG_igraph <- RG_to_igraph(RG, determine_MOIs(y))   plot_RG(RG_igraph, vertex.size = 25, vertex.label = NA)   box() }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/intra-episode-siblings.html","id":"example-of-a-group-of-four-intra-episode-siblings-collapsing-to-two","dir":"Articles","previous_headings":"","what":"Example of a group of four intra-episode siblings collapsing to two","title":"Explore treatment of intra-episode siblings","text":"showing groups intra-episode siblings collapse pairs intra-episode siblings, write function simulate data given allelic richness (marker cardinality) enrolment episode comprising stranger plus group four siblings, two one oocyst, two another, drawing two unrelated parental genotypes, recurrence one sibling. Technically, enrolment episode contains five genetically distinct genotypes thus MOI five. However, MOI estimates based maximum per-marker allele counts three one markers polyallelic: two one markers biallelic: Suppose estimate MOIs 3 1 biallelic data using external software exploits heteroallelic marker counts (rather maximum number per-marker alleles), input external estimates compute_posterior. Providing data simulated large number markers (200 ), recover almost exactly posterior probabilities using polyallelic data without user-specified MOIs biallelic data user-specified MOIs three one However, given polyallelic data likelihoods following graphs cliques three intra-episode siblings zero:  Whereas, relationships non-zero likelihoods given biallelic data:","code":"simulate_data <- function(marker_cardinality){      # Magic numbers / quantities   set.seed(5) # For reproducibility   n_markers <- 200 # Number of markers   n_strangers <- 3 # Number of stranger parasites   n_oocysts <- 2 # Number of oocysts to draw from      # Derived quantities   alleles <- letters[1:marker_cardinality]   markers <- paste0(\"m\", 1:n_markers) # Marker names      # Uniform allele frequencies    fs <- sapply(markers, simplify = FALSE,                 function(m) setNames(rep(1/marker_cardinality, marker_cardinality), alleles))      # Sample strangers   strangers <- sapply(1:n_strangers, function(i) {     sapply(markers, function(t) sample(names(fs[[t]]), size = 1, prob = fs[[t]]))   })      # Designate strangers   parents <- strangers[, 1:2]      # Map the markers to chromosomes. Assume equally sized chromosomes — reasonable   # if and only if we later assume an equal number of crossovers per chromosome   chrs_per_marker <- round(seq(0.51, 14.5, length.out = n_markers))      # Sample parental allocations dependently per-oocyst    cs <- lapply(1:n_oocysts, function(o) recombine_parent_ids(chrs_per_marker))      # Construct children from parental allocations    all_children <- lapply(1:n_oocysts, function(o) {     oocyst_chidren <- sapply(1:n_markers, function(i) {       sapply(1:ncol(cs[[o]]), function(j) parents[i,cs[[o]][i,j]])     })     colnames(oocyst_chidren) <- markers     return(oocyst_chidren)   })      # Make enrolment infection   enrol <- apply(rbind(all_children[[1]][1:2,],                         all_children[[2]][1:2,],                         strangers[,3]), 2, unique, simplify = F)      # Make paired data   data <- list(enrol = enrol, recur = as.list(all_children[[1]][1,]))      return(list(data = data, fs = fs)) } polyallelic <- simulate_data(10)  determine_MOIs(polyallelic$data) #> [1] 3 1 biallelic <- simulate_data(2)  determine_MOIs(biallelic$data) #> [1] 2 1 ppost <- suppressMessages(compute_posterior(y = polyallelic$data,                                              fs = polyallelic$fs,                                              return.logp = T)) bpost <- suppressMessages(compute_posterior(y = biallelic$data,                                              fs = biallelic$fs,                                              MOIs = c(3,1), return.logp = T))  ppost$marg #>               C         L             I #> recur 0.6666667 0.3333333 2.708985e-116 bpost$marg #>               C         L            I #> recur 0.6666663 0.3333337 4.625927e-18 llikes <- sapply(bpost$RGs, function(RG) RG$logp) # Extract log likelihoods any(is.infinite(llikes)) # Are there any minus infinity log likelihoods? #> [1] FALSE"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/intra-episode-siblings.html","id":"contribution-to-upper-bounds","dir":"Articles","previous_headings":"","what":"Contribution to upper bounds","title":"Explore treatment of intra-episode siblings","text":"summation graphs cliques three siblings possibly redundant given graphs practical support. Even graphs zero likelihood, contribute maximum probabilities recrudescence / reinfection conditionally uniform prior graphs. However, upper bounds probability reinfection / recrudescence given single recurrence contribution small, especially reinfection:  recrudescence, 3 MOI vectors (circled ) result absolute difference greater 0.0175. feature large MOIs (MOI vectors 52, 62, 71) thus whose graph spaces include graphs largest cliques intra-episode siblings.  contribution likely smaller vectors three MOIs computationally feasible Pv3Rs constituent MOIs necessarily less 7 (computationally feasible MOI vectors total genotype count eight).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"summary-of-contents","dir":"Articles","previous_headings":"","what":"Summary of contents","title":"Understand posterior estimates","text":"vignette document output compute_posterior() statistical model underpinning well specified misspecified. Specifically, document output compute_posterior() model well specified data missing, data uninformative, data limited one episode, data incomparable across episodes, data limited one marker. model well specified data many markers, show maximum probability recrudescence / reinfection depends per-episode genotype counts (.e., multiplicities infections, MOIs), episode count, position recurrence sequence episodes, thus comment dependencies impact interpretation uncertainty. Finally, summarise results output compute_posterior() model misspecified meiotic siblings, half siblings, parent child-like siblings, genotyping errors de novo mutations [-]. detailed result, see [development files Pv3Rs source package] (https://github.com/aimeertaylor/Pv3Rs/tree/main/DevFiles/RelationshipStudy). characterised model misspecification due inbred parasites. Allele frequency estimates encode population-level relatedness locus--locus (Mehra et al. 2025). Allele frequency estimates plugged statistical model underpinning Pv3Rs. Providing computed sample drawn parasite population trial participants also draw, need compensate elevated relatedness locus--locus population level. However, inter-locus dependence (linkage disequilibrium) liable generate overconfident posterior probabilities. Population structure (e.g., household effects) lead misclassification reinfection relapse / recrudescence. view, recurrence classification presence population structure best understood using complementary population genetic sensitivity analyses.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"missing-data","dir":"Articles","previous_headings":"","what":"Missing data","title":"Understand posterior estimates","text":"data entirely missing, compute_posterior() returns prior. data missing user provides MOIs incompatible recrudescence, compute_posterior() returns prior re-weighted exclusion recrudescence.","code":"fs = list(m1 = c(\"A\" = 0.5, \"B\" = 0.5)) # Allele frequencies y = list(enrol = list(m1 = NA), recur = list(m1 = NA)) # Missing data suppressMessages(compute_posterior(y, fs))$marg # Posterior #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333 suppressMessages(compute_posterior(y, fs, MOIs = c(1,2)))$marg  #>       C   L   I #> recur 0 0.5 0.5"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"uniformative-data","dir":"Articles","previous_headings":"","what":"Uniformative data","title":"Understand posterior estimates","text":"data entirely uninformative genetic diversity, compute_posterior() returns prior.","code":"fs = list(m1 = c(\"A\" = 1)) # Unit allele frequency: no genetic diversity y = list(list(m1 = \"A\"), recur = list(m1 = \"A\")) # Data: not missing suppressMessages(compute_posterior(y, fs))$marg # Posterior #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333"},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"homoallelic-data-without-user-specified-mois-prior-return","dir":"Articles","previous_headings":"Data on only one episode","what":"Homoallelic data without user-specified MOIs: prior return","title":"Understand posterior estimates","text":"one episode homoallelic data user specify MOI > 1, compute_posterior() returns prior.","code":"fs = list(m1 = c(\"A\" = 0.5, \"B\" = 0.5)) # Allele frequencies y <- list(enrol = list(m1 = NA), recur1 = list(m1 = \"A\")) # No enrolment data suppressMessages(compute_posterior(y, fs))$marg # Posterior #>                C         L         I #> recur1 0.3333333 0.3333333 0.3333333"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"heteroallelic-data-prior-proximity","dir":"Articles","previous_headings":"Data on only one episode","what":"Heteroallelic data: prior proximity","title":"Understand posterior estimates","text":"one episode heteroallelic data, MOI model necessarily exceeds one model assumes false positivity. posterior close prior equal data slightly informative: relationship graphs intra-episode siblings, heteroallelic data limit summation identity--descent partitions partitions least two cells episode data. lower bound cell count increases number distinct alleles observed.","code":"# Allele frequencies  fs = list(m1 = c('A' = 0.25, 'B' = 0.25, 'C' = 0.25, 'D' = 0.25))   # MOI at enrolment increases with number of observed alleles:   yMOI2 <- list(enrol = list(m1 = c('A','B')), recur = list(m1 = NA)) yMOI3 <- list(enrol = list(m1 = c('A','B','C')), recur = list(m1 = NA)) yMOI4 <- list(enrol = list(m1 = c('A','B','C','D')), recur = list(m1 = NA)) ys <- list(yMOI2, yMOI3, yMOI4) do.call(rbind, lapply(ys, function(y) {   suppressMessages(compute_posterior(y, fs))$marg }))  #>               C         L         I #> recur 0.3292683 0.3414634 0.3292683 #> recur 0.3260870 0.3478261 0.3260870 #> recur 0.3248359 0.3503282 0.3248359  # MOI increases with external input: MOIs <- list(c(2,1), c(2,2), c(3,2)) # user-specified MOIs y <- list(enrol = list(m1 = c('A','B')), recur = list(m1 = NA)) # Data  do.call(rbind, lapply(MOIs, function(x) {   suppressMessages(compute_posterior(y, fs, MOIs = x))$marg }))  #>               C         L         I #> recur 0.3292683 0.3414634 0.3292683 #> recur 0.3250000 0.3500000 0.3250000 #> recur 0.3334508 0.3330983 0.3334508"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"rare-homoallelic-data-with-user-specified-mois-exceeding-1-prior-departure","dir":"Articles","previous_headings":"Data on only one episode","what":"Rare homoallelic data with user-specified MOIs exceeding 1: prior departure","title":"Understand posterior estimates","text":"data homoallelic, user specifies MOIs greater one, observed allele rare, posterior departs prior rare intra-episode allelic repeats probable given relationship graphs intra-episode relatedness.  per-graph likelihood appreciable relationship graphs distinct parasite genotypes first episode siblings","code":"y <- list(enrol = list(m1 = 'A'), list(m1 = NA)) # Homoallelic data MOIs <- list(c(2,1), c(3,2), c(5,1)) # Different MOIs with first MOI > 1 fs = list(m1 = c(\"A\" = 0.01, \"B\" = 0.99)) # Rare observed allele"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"data-are-incomparable-across-episodes","dir":"Articles","previous_headings":"","what":"Data are incomparable across episodes","title":"Understand posterior estimates","text":"data multiple episodes comparable data across episodes, compute_posterior() behaves similarly data limited one episode: returns prior data homoallelic without user-specified MOIs > 1, output remains close prior data heteroallelic, output departs prior data homoallelic rare user-specified MOIs > 1.","code":"# Allele frequencies fs = list(m1 = c(\"A\" = 0.01, \"B\" = 0.99),            m2 = c(\"A\" = 0.01, \"B\" = 0.99))   # Data with an incomparable homoallelic call y_hom <- list(enrol = list(m1 = \"A\", m2 = NA),                recur = list(m1 = NA, m2 = \"A\"))  # Data with an incomparable heteroallelic call y_het <- list(enrol = list(m1 = c(\"A\", \"B\"), m2 = NA),                recur = list(m1 = NA, m2 = c(\"A\", \"B\")))  suppressMessages(compute_posterior(y_hom, fs))$marg # Prior return  #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333 suppressMessages(compute_posterior(y_het, fs))$marg # Prior proximity #>               C         L         I #> recur 0.3370787 0.3595506 0.3033708 suppressMessages(compute_posterior(y_hom, fs, MOIs = c(2,2)))$marg # Prior departure #>               C         L        I #> recur 0.5142862 0.2183909 0.267323"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"data-on-only-one-marker","dir":"Articles","previous_headings":"","what":"Data on only one marker","title":"Understand posterior estimates","text":"data single marker comparable across episodes, output compute_posterior() depends observation type frequencies observed alleles. example, rare match informative: quashes posterior probability reinfection. partial rare match also informative, quashing posterior probability reinfection. match common allele informative: states possible posteriori. partial match common allele informative: states possible posteriori. mismatch informative: quashes posterior probability recrudescence. latter demonstrates sensitivity recrudescence inference assumption model genotyping errors: genotyping error generates single mismatch, posterior probability recrudescence quashed.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"data-on-only-two-markers","dir":"Articles","previous_headings":"","what":"Data on only two markers","title":"Understand posterior estimates","text":"data second marker added second observation consistent first strength inference generally increases (see arrows entering regions posterior probability greater 0.5); exception addition common match common partial match, informative (central arrow). mismatch added rare match (diamond), relapse becomes probable state. demonstrates requirement multiple markers relapse inference.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"data-on-many-markers","dir":"Articles","previous_headings":"","what":"Data on many markers","title":"Understand posterior estimates","text":"Given non-zero prior probabilities, data increase number markers genotyped, posterior probabilities given recurrence converge either relapse posterior probability one data suggest episode interest linked previous episodes regular sibling relationships recrudescence posterior probability less one data suggest episode interest linked previous episode clonal relationships reinfection posterior probability less one data suggest episode interest linked previous episodes regular sibling clonal relationships Recrudescence / reinfection probabilities necessarily converge uncertain values genetic data compatible recrudescence / reinfection also compatible relapse.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"posterior-bounds","dir":"Articles","previous_headings":"Data on many markers","what":"Posterior bounds","title":"Understand posterior estimates","text":"assume priori relationship graphs compatible given recurrence state sequence uniformly distributed, relationship graphs compatible sequences recrudescence / reinfection subset compatible sequences relapse, bounds induced prior non-marginal posterior probabilities can computed priori function prior recurrence state sequences prior relationship graphs; see vignette(\"understand-graph-prior\", \"Pv3Rs\"). probability mass function uniformly distributed discrete random variable depends size support, prior uniformly distributed graphs (thus bounds posterior induced prior) depends size graph space. Graph space size depends constitute graph size (graphs within space size). Graphs many vertices parasite genotypes within across episodes. , graph size depends episode counts per-episode MOIs, vary across trial participants. Using rare matched mismatched data 100 markers, demonstrate dependency per-episode MOIs prior-induced posterior bounds single recurrence. also demonstrate maximum marginal probabilities recrudescence / relapse depend episode counts adding recurrences recurrent data. However, maxima based knowledge recurrent data first recurrence. words, computable priori.","code":"marker_count <- 100 # Number of markers ms <- paste0(\"m\", 1:marker_count) # Marker names  all_As <- sapply(ms, function(t) \"A\", simplify = F) # As for all markers all_Bs <- sapply(ms, function(t) \"B\", simplify = F) # Bs for all markers no_data <- sapply(ms, function(t) NA, simplify = F) # NAs for all markers fs <- sapply(ms, function(m) c(\"A\" = 0.01, \"B\" = 0.99), simplify = FALSE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"increasing-per-episode-mois","dir":"Articles","previous_headings":"Data on many markers","what":"Increasing per-episode MOIs","title":"Understand posterior estimates","text":"posterior probabilities recrudescence increase increasing graph size MOIs balanced. posterior probabilities reinfection increase increasing graph size.","code":"MOIs <- list(c(1,1), c(2,1), c(2,2))  y_match <- list(enrol = all_As, recur = all_As) y_mismatch <- list(enrol = all_As, recur = all_Bs) #> NULL"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"digression-counts-of-intra-episode-siblings","dir":"Articles","previous_headings":"Data on many markers > Increasing per-episode MOIs","what":"Digression: counts of intra-episode siblings","title":"Understand posterior estimates","text":"increase per-episode MOIs, can increase user-specified MOIs without changing data, can increase allelic diversity data, s.t. MOIs modelled Pv3Rs increase without user-specified MOIs. Either way, get maximum probabilities: graph likelihoods change:  homoallelic data elevated user-specified MOIs, intra-episode parasites maximum likelihood graphs siblings. heteroallelic data, intra-episode parasites maximum likelihood graphs strangers. maximum probabilities recrudescence. One upshot maximum probabilities increased increasing counts intra-episode siblings. Arguably, maximum probabilities increase two intra-episode siblings siblings independent. practice, MOIs Pv3Rs model based realistic MOI estimates, groups three siblings modelled groups two; see vignette(\"intra-episode-siblings\", \"Pv3Rs\"). END DIGRESSION","code":"all_ACs <- sapply(ms, function(t) c(\"A\", \"C\"), simplify = F) # A&C for all  all_BEs <- sapply(ms, function(t) c(\"B\", \"E\"), simplify = F) # A&C for all  all_ACDs <- sapply(ms, function(t) c(\"A\", \"C\", \"D\"), simplify = F) # A&C for all  fs <- sapply(ms, function(m) c(\"A\" = 0.01, \"B\" = 0.01, \"C\" = 0.01,                                 \"D\" = 0.01, \"E\" = 0.96), simplify = FALSE)  hom_match_data <- list(enrol = all_As, hom_match_data = all_As) het_match_data <- list(enrol = all_ACDs, het_match_data = all_ACs) hom_mismatch_data <- list(enrol = all_As, hom_mismatch_data = all_Bs) het_mismatch_data <- list(enrol = all_ACDs, het_mismatch_data = all_BEs)  rbind(suppressMessages(compute_posterior(hom_match_data, fs, MOIs = c(3,2))$marg),        suppressMessages(compute_posterior(het_match_data, fs)$marg),        suppressMessages(compute_posterior(hom_mismatch_data, fs, MOIs = c(3,2))$marg),       suppressMessages(compute_posterior(het_mismatch_data, fs)$marg)) #>                           C          L             I #> hom_match_data    0.8514851 0.14851485 9.084162e-231 #> het_match_data    0.8514851 0.14851485  0.000000e+00 #> hom_mismatch_data 0.0000000 0.05494505  9.450549e-01 #> het_mismatch_data 0.0000000 0.05494505  9.450549e-01"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"increasing-episode-counts","dir":"Articles","previous_headings":"Data on many markers","what":"Increasing episode counts","title":"Understand posterior estimates","text":"Recurrences can added without adding data marginal probability first recurrence recrudescence / reinfection depends total number recurrences:  example recrudescence probabilities converge maxima 1, 2, 5 100 markers:  Note maxima bounds imposed prior: based knowledge recurrent data first recurrence; see vignette(\"understand-graph-prior\", \"Pv3Rs\").","code":"ys_match <- list(\"1_recurrence\" = list(enrol = all_As,                                         recur1 = all_As),                  \"2_recurrence\" = list(enrol = all_As,                                         recur1 = all_As,                                        recur2 = no_data),                  \"3_recurrence\" = list(enrol = all_As,                                         recur1 = all_As,                                        recur2 = no_data,                                        recur3 = no_data))  ys_mismatch <- list(\"1_recurrence\" = list(enrol = all_As,                                            recur1 = all_Bs),                     \"2_recurrence\" = list(enrol = all_As,                                            recur1 = all_Bs,                                           recur2 = no_data),                     \"3_recurrence\" = list(enrol = all_As,                                            recur1 = all_Bs,                                           recur2 = no_data,                                           recur3 = no_data)) #> NULL #> NULL"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"position-in-a-sequence","dir":"Articles","previous_headings":"Data on many markers","what":"Position in a sequence","title":"Understand posterior estimates","text":"distribution relationship graphs invariant different orderings states sequence (graphs compatible reinfection beginning versus end sequence three episodes, example), position recurrence sequence bearing posterior estimates. effect negligible episodes data many markers: Instead, consider sequences episodes observations (Os) episodes data (Ns):","code":"y <- list(enrol = all_As,            recur1 = all_As,            recur2 = all_As,            recur3 = all_As) suppressMessages(compute_posterior(y, fs))$marg #>                C         L            I #> recur1 0.7720588 0.2279412 5.585675e-23 #> recur2 0.7720588 0.2279412 5.316220e-23 #> recur3 0.7720588 0.2279412 5.044004e-23 ys_match <- list(\"NOO\" = list(enrol = no_data,                                recur1 = all_As,                               recur2 = all_As),                  \"ONO\" = list(enrol = all_As,                                recur1 = no_data,                               recur2 = all_As),                  \"OON\" = list(enrol = all_As,                                recur1 = all_As,                               recur2 = no_data))  ys_mismatch <- list(\"NOO\" = list(enrol = no_data,                                   recur1 = all_As,                                  recur2 = all_Bs),                     \"ONO\" = list(enrol = all_As,                                   recur1 = no_data,                                  recur2 = all_Bs),                      \"OON\" = list(enrol = all_As,                                   recur1 = all_Bs,                                  recur2 = no_data)) #> NULL"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"highly-informed-recurrences","dir":"Articles","previous_headings":"Data on many markers > Position in a sequence","what":"Highly informed recurrences","title":"Understand posterior estimates","text":"first recurrence sequence OON (upward purple 1 triangle) slightly lower probability recrudescence second recurrence sequence NOO (upward green 2 triangle) despite recurrences rare observations match directly preceding episode. first recurrence sequence OON (downward purple 1 triangle) slightly higher probability reinfection second recurrence sequence NOO (downward green 2 triangle) despite recurrences observations mismatch directly preceding episode.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"weakly-and-uninformed-recurrences","dir":"Articles","previous_headings":"Data on many markers > Position in a sequence","what":"Weakly and uninformed recurrences","title":"Understand posterior estimates","text":"Unsurprisingly, posterior first recurrence sequence NOO close prior (preceding data), likewise second recurrence sequence OON (data). surprisingly, posterior first recurrence sequence ONO close prior, despite data. closer inspection, surprising reasons explained . match data (upward triangles), strong evidence clonal edge episodes one three ONO incompatible recurrence sequences ending reinfection reinfection followed recrudescence, informing strongly second recurrence weakly first recurrence. comparison, strong evidence clonal edge episodes two three NOO incompatible sequences recurrences ending reinfection, informing second recurrence ; likewise, strong evidence clonal edge episodes one two OON incompatible sequences recurrences starting reinfection, informing first recurrence . close inspection upward orange 1 triangle makes intuitive sense: know first recurrence followed second MOI = 1 recurrence clone MOI = 1 enrolment episode, unlikely second recurrence clone drawn new mosquito recrudescence reinfection. , data enrolment episode second recurrence tell us something first recurrence, thus posterior estimate first recurrence deviates prior even though first recurrence data. explanation mismatch data (downward triangles) sequence ONO similar match data: strong evidence stranger edge episodes one three incompatible double recrudescence, posterior first recurrence (downward orange 1 triangle) deviates prior despite first recurrence data.","code":"epsilon <- .Machine$double.eps # Very small probability names(which(suppressMessages(compute_posterior(y = ys_match[[\"ONO\"]], fs))$joint < epsilon)) #> [1] \"IC\" \"CI\" \"LI\" \"II\" names(which(suppressMessages(compute_posterior(y = ys_match[[\"NOO\"]], fs))$joint < epsilon)) #> [1] \"CI\" \"LI\" \"II\" names(which(suppressMessages(compute_posterior(y = ys_match[[\"OON\"]], fs))$joint < epsilon)) #> [1] \"IC\" \"IL\" \"II\" epsilon <- .Machine$double.eps # Very small probability names(which(suppressMessages(compute_posterior(y = ys_mismatch[[\"ONO\"]], fs))$joint < epsilon)) #> [1] \"CC\" names(which(suppressMessages(compute_posterior(y = ys_mismatch[[\"NOO\"]], fs))$joint < epsilon)) #> [1] \"CC\" \"LC\" \"IC\" names(which(suppressMessages(compute_posterior(y = ys_mismatch[[\"OON\"]], fs))$joint < epsilon)) #> [1] \"CC\" \"CL\" \"CI\""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"interpreting-uncertainty","dir":"Articles","previous_headings":"","what":"Interpreting uncertainty","title":"Understand posterior estimates","text":"Uncertain posterior estimates can uncertain two reasons mutually exclusive: data needed states fully identifiable also important bear mind fact , Pv3Rs model, trial participants different epside counts per-episode MOIs different maximum probabilities recrudescence / reinfection. example, use common threshold 0.8 classify probable reinfection assuming recurrence states equally likely priori, can discount priori trail participants single monoclonal recurrence following monoclonal enrolment episode posterior reinfection probabilities never exceed 0.75, even data highly informative reinfection: , given trial participant, probability recrudescence / reinfection depends position within sequence, especially one episodes data.","code":"y <- list(enrol = all_As, recur = all_Bs) fs <- sapply(ms, FUN = function(m) c(\"A\" = 0.5, \"B\" = 0.5), simplify = FALSE)  # Using the default uniform prior on recurrence states suppressMessages(compute_posterior(y, fs))$marg #>       C    L    I #> recur 0 0.25 0.75  # Using a non-uniform prior on recurrence states prior <- as.matrix(data.frame(\"C\" = 0.25, \"L\" = 0.25, \"I\" = 0.5)) suppressMessages(compute_posterior(y, fs, prior))$marg #>       C         L         I #> recur 0 0.1428571 0.8571429"},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"methods","dir":"Articles","previous_headings":"Meiotic siblings","what":"Methods","title":"Understand posterior estimates","text":"simulated data generated results initial infection containing two three meiotic siblings recurrent stranger clone regular sibling meiotic sibling Posterior probabilities computed assuming recurrence states equally likely priori.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"results","dir":"Articles","previous_headings":"Meiotic siblings","what":"Results","title":"Understand posterior estimates","text":"initial infection contains two meiotic siblings compute_posterior() well behaved maximum likelihood true relationship graph (shown). Posterior probabilities converge probable reinfection recurrent parasite stranger, probable recrudescence recurrent parasite clone, certain relapse recurrent parasite regular sibling, certain relapse recurrent parasite meiotic sibling.  initial infection contains three meiotic siblings recurrent parasite either stranger clone, posterior probabilities converge correctly probable reinfection probable recrudescence, respectively, maximal values given graphs relationships two, three, parasites initial infection.  Relationship graphs (shown) wrong two reasons: relationship graphs two, three, parasites initial infection two alleles per marker. Although technically incorrect, behaviour arguably desirable (see digression ). highest likelihood relationship graphs stranger parasites initial episode prevalence data three four meiotic siblings identical bulk data parents strangers. can force graphs three distinct parasites initial episode specifying external MOIs. recovers maximum likelihood true relationship graphs. However, correct MOIs unknowable practice: collection siblings two parents can ever diverse two parents. initial infection contains three meiotic siblings recurrent parasite regular meiotic sibling, posterior probabilities converge probable recrudescence maximum likelihood graphs clonal edge sibling relapse, either two stranger parasites initial episode external MOIs specified, three sibling parasites initial episode correct MOIs (unknowable practice) provided externally.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"methods-1","dir":"Articles","previous_headings":"Half siblings","what":"Methods","title":"Understand posterior estimates","text":"simulated data three half siblings: two initial episode, third recurrence: child parents 1 2 initial episode child parents 1 3 initial episode child parents 2 3 recurrence explored two scenarios: one parental parasites draw allele distribution. Another admixture parent 1 draws alleles disproportionally parents 2 3. admixture scenario improbable. explore worse case scenario: contrived maximally hamper relapse classification.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"results-1","dir":"Articles","previous_headings":"Half siblings","what":"Results","title":"Understand posterior estimates","text":"general, parental parasites draw allele distribution, frequency certain relapse increases erratically number markers genotyped. particular case three equifrequent alleles per marker, can show theoretically system behaves erratically small perturbation ratio observations (alleles match across three half siblings, alleles different, intra-episode alleles match, inter-episode alleles match) can lead large deviation odds relapse versus reinfection; see vignette(\"understand-half-sibs\", \"Pv3Rs\"). purple, red, green trajectories higher expected 0.5 intra--inter match ratios; moreover, purple trajectory’s intra--inter match ratio consistently exceeds 0.5×log2(25)0.5\\times \\text{log}_2(\\dfrac{2}{5}), condition found theoretically concentrate posterior probability reinfection certain conditions; , see vignette(\"understand-half-sibs\", \"Pv3Rs\"). intra-episode parasites systematically share rare alleles (admixture imbalanced allele frequencies), frequency probable reinfection increases erratically number markers genotyped. scenarios, likelihood true graph siblings within across episodes quashed soon distinct alleles three parents observed given marker. general, parasites draw allele distribution, maximum likelihood graphs two one inter-episode sibling edge. intra-episode parasites systematically share rare alleles, maximum likelihood graph one one intra-episode sibling edge.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"methods-2","dir":"Articles","previous_headings":"Parent-child like siblings","what":"Methods","title":"Understand posterior estimates","text":"simulated data three parent-child like siblings: child selfed parent 1 initial episode child parents 1 2 initial episode child selfed parent 2 recurrence Aside: alternative children selfed parents initial episode equivalent meiotic case three mieotic siblings initial episode prevalence data three meiotic siblings equivalent prevalence data two stranger parents leads probable recrudescence rather certain relapse number markers genotyped. half-siblings, explored two scenarios: one parental parasites draw allele distribution. Another admixture parent 1 draws alleles disproportionally parents 2 3. admixture scenario improbable. explore worse case scenario: contrived maximally hamper relapse classification.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/understand-posterior.html","id":"results-2","dir":"Articles","previous_headings":"Parent-child like siblings","what":"Results","title":"Understand posterior estimates","text":"parental parasites draw allele distribution, frequency certain relapse increases erratically number markers genotyped.  intra-episode parasites systematically share rare alleles (admixture imbalanced allele frequencies), frequency probable reinfection increases erratically number markers genotyped.  general, parasites draw allele distribution, maximum likelihood graph true graph siblings within across episodes. Meanwhile, intra-episode parasites systematically share rare alleles, maximum likelihood graph one one intra-episode sibling edge.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Aimee Taylor. Author, maintainer. Yong See Foo. Author. European Union, Project 101110393. Funder.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Taylor , Foo Y (2025). Pv3Rs: Estimate cause recurrent vivax malaria using genetic data. R package version 0.0.0.9000, https://aimeertaylor.github.io/Pv3Rs/.","code":"@Manual{,   title = {Pv3Rs: Estimate the cause of recurrent vivax malaria using genetic data},   author = {Aimee Taylor and Yong See Foo},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://aimeertaylor.github.io/Pv3Rs/}, }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"pv3rs-","dir":"","previous_headings":"","what":"Estimate the cause of recurrent vivax malaria using genetic data","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"R package Plasmodium vivax molecular correction: statistical genetic inference P. vivax Relapse Recrudescence Reinfection core function compute_posterior() can used obtain per-person posterior probabilities relapse, recrudescence, reinfection (recurrence states) using P. vivax genetic data across multiple episodes update prior recurrence states, ideally informative (e.g., based time--event information). Two important features general: plot_data() can used visualise genetic data molecular correction regardless analytical method; example, Plasmodium falciparum data intended analysis using match-counting algorithm. plot_simplex() can used visualise per-recurrence posterior probabilities relapse, recrudescence, reinfection, vector three numbers zero one sum one.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"pre-release-state","dir":"","previous_headings":"Please be aware of the following points!","what":"Pre-release state:","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"R package still development may contain errors. Moreover, statistical model around Pv3Rs R package developed yet peer-reviewed thus liable modification. model documented preprint [1]. model builds upon prototype documented [2] (see [1] better understand model underpinning Pv3Rs differs prototype). [1] Taylor, Foo & White, 2022 [2] Taylor & Watson et al. 2019","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"prior-considerations","dir":"","previous_headings":"Please be aware of the following points!","what":"Prior considerations:","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"Genetic data modelled using Bayesian model, whose prior ideally informative ([2] prior estimates generated time--event model built James Watson) cause recurrent P. vivax malaria always identifiable genetic data alone: data consistent recurrent parasites relatively unrelated preceding infections, reinfection relapse plausible; meanwhile, data compatible recurrent parasites clones preceding infection, recrudescence relapse plausible. main Pv3Rs function, compute_posterior(), used estimate probable cause recurrent P. falciparum malaria setting prior probability relapse zero. However, current version Pv3Rs suboptimal P. falciparum molecular correction: genotyping errors, accounted current Pv3Rs model, liable lead misclassification recrudescence reinfection probability relapse zero priori (recrudescence relapse prior probability relapse exceeds zero).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"notable-assumptions-and-limitations","dir":"","previous_headings":"Please be aware of the following points!","what":"Notable assumptions and limitations:","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"model, Pv3Rs makes various assumptions limit capabilities settings. explained detail summarised table.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"mutually-exclusive-recurrent-states","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Mutually exclusive recurrent states","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"model recurrent states (relapse, recrudescence, reinfection) mutually exclusive. Pv3Rs designed view towards clinical trials study participants actively followed frequently detected infections treated extent post-treatment parasitaemia drops detectable level recurrence, occurs. studies infections persist untreated /events time accumulate, concept recurrence ill-defined, output Pv3Rs might meaningful.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"complexities-of-molecular-correction-that-exceed-data-sampled","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Complexities of molecular correction that exceed data sampled","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"model complexities around molecular correction. example, model population structure (e.g., household effects) failure capture low-density clone body blood sample limited volume [Snounou Beck, 1998], hidden biomass spleen bone marrow (alternative source P. vivax recurrence) [Markus, 2019]. study design , urge user interpret Pv3Rs’ output conditional input. example, expect Pv3Rs output probable relapse person reinfected new mosquito parasites recently related caused previous infection, might happen household transmission chains.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"sibling-misspecification","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Sibling misspecification","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"Relapsing parasites siblings parasites previous infections can meiotic, parent-child-like, regular half siblings, model sibling parasites regular siblings via following assumptions: - allele inheritance independent (true meiotic siblings) - sibling relationships transitive (true parent-child-like trios half-sibling trios) - alleles sibling cluster drawn two parental alleles (true half siblings). experience, half sibling misspecification leads misclassification relapses reinfections; see vignette “Understand half-sibling misspecification”. descriptive study explore extent half-sibling misspecification recommended (example provided upcoming manuscript).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"observation-errors-and-de-novo-mutations","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Observation errors and de novo mutations","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"model undetected alleles, genotyping errors, de novo mutations. Recall recrudescent parasites modelled perfect clones Pv3Rs. , posterior probability recrudescence rendered zero errors mutations. becomes likely data markers. Sensitivity analyses explore impact errors mutations recurrence state estimates merited.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"interpreting-probable-reinfection-and-recrudescence","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Interpreting probable reinfection and recrudescence","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"data sufficiently informative distinguish recrudescence relapse (reinfection relapse), posterior probabilities recrudescence relapse (reinfection relapse) heavily influenced assumption distribution graphs uniform priori (see vignette “Understand graph prior ramifications”). development biologically-principled generative model parasite relationships merited.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"computational-limits","dir":"","previous_headings":"Please be aware of the following points!","what":"Computational limits:","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"Pv3Rs scales hundreds markers whole-genome sequence (WGS) data. recommend running compute_posterior() data whose total genotype count (sum per-episode multiplicities infection) exceeds eight. total genotype counts exceeds eight multiple recurrences, might possible generate recurrent state estimates recurrences analysing episodes pairwise (approach used [2]). tested per-marker allele limit compute_posterior(). high marker cardinalities lead small allele frequencies thus underflow problems.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"population-level-allele-frequencies","dir":"","previous_headings":"Please be aware of the following points!","what":"Population-level allele frequencies:","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"addition paired data, compute_posterior() requires input population-level allele frequencies. minimise bias due within-host selection recrudescent parasites, recommend using enrolment episodes estimate population-level allele frequencies, ideally enrolment episodes study participants selected random, study participants experience recurrence. said, recurrences either reinfections relapses, draws mosquito population (albeit delayed draw case relapse), assuming systematic within-patient selection (might occur infections encounter lingering drug pressure), estimates based episodes unbiased precise based enrolment episodes .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"read-count-data","dir":"","previous_headings":"Please be aware of the following points!","what":"Read-count data:","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"Unfortunately, Pv3Rs model exploit read count data present. However, read count data used compute population-level allele frequencies, assuming biased experimental artefacts.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimate the cause of recurrent vivax malaria using genetic data","text":"","code":"# Install or update latest stable version of devtools from CRAN install.packages(\"devtools\")  # Install R.rsp, a vignette builder used to build LaTeX vignettes in Pv3Rs install.packages(\"R.rsp\")  # Install Pv3Rs from GitHub  # I highly recommend doing this in RStudio as RStudio installs pandoc needed to build vignettes. # If you're working in R outside of RStudio you might need to install pandoc and check its path;  # otherwise set build_vignettes = FALSE devtools::install_github(\"aimeertaylor/Pv3Rs\", build_vignettes = TRUE)  # Load and attach Pv3Rs library(Pv3Rs)  # List links to all available documentation help(package = \"Pv3Rs\")  # List links to vignettes vignette(package = \"Pv3Rs\")  # View function documentation, e.g.,  ?compute_posterior"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/Pv3Rs-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Pv3Rs: Estimate the cause of recurrent vivax malaria using genetic data — Pv3Rs-package","title":"Pv3Rs: Estimate the cause of recurrent vivax malaria using genetic data — Pv3Rs-package","text":"Estimate per-person posterior probabilities recurrent Plasmodium vivax (Pv) infection recrudescence, relapse, reinfection (3Rs) using per-person P. vivax genetic data two episodes.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/Pv3Rs-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pv3Rs: Estimate the cause of recurrent vivax malaria using genetic data — Pv3Rs-package","text":"Maintainer: Aimee Taylor aimee.taylor@pasteur.fr (ORCID) Authors: Yong See Foo contributors: European Union, Project 101110393 [funder]","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"Converts RG encoded list igraph object, requires memory allocation can plotted using plot_RG.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"","code":"RG_to_igraph(RG, MOIs)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"RG List encoding RG; see Value enumerate_RGs igraph = FALSE. MOIs Vector per-episode multiplicities infection (MOIs), .e., numbers vertices per episode; adds graph attribute used plot_RG group genotypes episodes.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"weighted graph whose edge weights 1 0.5 encode clonal sibling relationships, respectively.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"","code":"MOIs <- c(3,2) set.seed(6) RG_as_list <- sample_RG(MOIs, igraph = FALSE) RG_as_igraph <- RG_to_igraph(RG_as_list,  MOIs)  # RG encoded as a list requires less memory allocation utils::object.size(RG_as_list) #> 2512 bytes utils::object.size(RG_as_igraph) #> 4568 bytes  # RG encoded as an igraph object can be plotted using plot_RG() and # manipulated using igraph functions plot_RG(RG_as_igraph, margin = rep(0,4), vertex.label = NA)   # Edge weights 1 and 0.5 encode clonal and sibling relationships igraph::E(RG_as_igraph)$weight #> [1] 0.5 0.5 1.0  # Vertex attribute group encodes episode membership igraph::V(RG_as_igraph)$group #> [1] 1 1 1 2 2"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"Computes per-person posterior probabilities P. vivax recurrence states — recrudescence, relapse, reinfection — using per-person genetic data two episodes; usage see Examples vignette(\"demonstrate-usage\") complete understanding posterior output see \"Understand posterior estimates\". Note: progress bar may increment non-uniformly (see Details); may appear stuck computations ongoing.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"","code":"compute_posterior(   y,   fs,   prior = NULL,   MOIs = NULL,   return.RG = FALSE,   return.logp = FALSE,   progress.bar = TRUE )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"y List lists encoding allelic data. outer list contains episodes chronological order. inner list contains named markers per episode. Marker names must consistent across episodes. NA indicates missing marker data; otherwise, specify per-marker vector distinct alleles detected (presently, compute_posterior support data proportional abundance detected alleles). Repeat alleles NA entries within allelic vectors ignored. Allele names arbitrary, allowing different data types, must correspond frequency names. fs List per-marker allele frequency vectors, names matching marker names y. Per-marker alleles frequencies mut contain one frequency per named allele, names matching alleles y. Per-marker frequencies must sum one. prior Matrix prior probabilities recurrence states per episode, rows episodes chronological order, columns named \"C\", \"L\", \"\" recrudescence, relapse reinfection, respectively. Row names ignored. NULL (default), per-episode recurrence states assumed equally likely priori. MOIs Vector per-episode multiplicities infection (MOIs). NULL (default), parsimonious MOIs compatible data used; see determine_MOIs. return.RG Logical; returns relationship graphs (default FALSE). Automatically set TRUE return.logp = TRUE. return.logp Logical; returns log-likelihood relationship graph (default FALSE). Setting TRUE disables permutation symmetry optimisation thus increases runtime, especially MOIs large. affect output posterior probabilities; see vignette(\"demonstrate-usage\"), also contains example permutation symmetry. progress.bar Logical; show progress bars (default TRUE). Note progress bar may update non-uniformly.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"List containing: marg Matrix marginal posterior probabilities recurrence, rows recurrences columns \"C\" (recrudescence), \"L\" (relapse), \"\" (reinfection). marginal probability sums subset joint probabilities. example, marginal probability \"C\" first two recurrences sums joint probabilities \"CC\", \"CL\", \"CI\". joint Vector joint posterior probabilities recurrence state sequence; within sequence \"C\", \"L\", \"\" used . RGs List lists encoding relationship graphs; returned return.RG = TRUE (default FALSE), log-likelihoods return.logp = TRUE (default FALSE). relationship graph encoded list can converted igraph object using RG_to_igraph thus plotted using plot_RG. details relationship graphs, see enumerate_RGs.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"compute_posterior() computes posterior probabilities proportional likelihood multiplied prior. likelihood sums : ways phase allelic data onto haploid genotypes graphs relationships haploid genotypes ways partition alleles clusters identity--descent enumerate possible relationship graphs haploid genotypes, pairs genotypes can either clones, siblings, strangers. likelihood sequence recurrence states can determined likelihood relationship graphs compatible said sequence. details enumeration relationship graphs can found enumerate_RGs. relationship graph, model sums possible identity--descent partitions. graphs compatible partitions others, log p(Y|RG) progress bar may advance non-uniformly. recommend running `compute_posterior() total genotype count (sum MOIs) exceeds eight many relationship graphs. Notable model assumptions limitations: siblings regular siblings Recrudescent parasites derive immediately preceding episode Recrudescence, relapse reinfection mutually exclusive Undetected alleles, genotyping errors, de novo mutations modelled Population structure various complexities confound molecular correction modelled","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"","code":"# Numerically named alleles y <- list(enrol = list(m1 = c('3','2'), m2 = c('1','2')),           recur1 = list(m1 = c('1','4'), m2 = c('1')),           recur2 = list(m1 = c('1'), m2 = NA)) fs <- list(m1 = c('1' = 0.78, '2' = 0.14, '3' = 0.07, '4' = 0.01),            m2 = c('1' = 0.27, '2' = 0.73)) compute_posterior(y, fs, progress.bar = FALSE) #> Number of valid relationship graphs (RGs) is 250 #> Computing log p(Y|RG) for 250 RGs #> Finding log-likelihood of each vector of recurrence states #>  #> $marg #>                C         L         I #> recur1 0.0000000 0.1949556 0.8050444 #> recur2 0.2938829 0.2476598 0.4584573 #>  #> $joint #>         CC         LC         IC         CL         LL         IL         CI  #> 0.00000000 0.05539481 0.23848807 0.00000000 0.05314490 0.19451493 0.00000000  #>         LI         II  #> 0.08641590 0.37204139  #>    # Arbitrarily named alleles, plotting per-recurrence posteriors y <- list(enrolment = list(marker1 = c(\"Tinky Winky\", \"Dipsy\"),                           marker2 = c(\"Tinky Winky\", \"Laa-Laa\", \"Po\")),           recurrence = list(marker1 = \"Tinky Winky\",                           marker2 = \"Laa-Laa\")) fs <- list(marker1 = c(\"Tinky Winky\" = 0.4, \"Dipsy\" = 0.6),            marker2 = c(\"Tinky Winky\" = 0.1, \"Laa-Laa\" = 0.1, \"Po\" = 0.8)) plot_simplex(p.coords = compute_posterior(y, fs, progress.bar = FALSE)$marg) #> Number of valid relationship graphs (RGs) is 30 #> Computing log p(Y|RG) for 30 RGs #> Finding log-likelihood of each vector of recurrence states #>     # Episode names are cosmetic: \"r1_prior\" is returned for \"r2\" y <- list(enrol = list(m1 = NA), r2 = list(m1 = NA), r1 = list(m1 = NA)) prior <- matrix(c(0.6,0.7,0.2,0.3,0.2,0), ncol = 3,                 dimnames = list(c(\"r1_prior\", \"r2_prior\"), c(\"C\", \"L\", \"I\"))) suppressMessages(compute_posterior(y, fs = list(m1 = c(a = 1)), prior))$marg #> Warning: Data and prior episode names disagree #> Warning: Markers m1 has data on one episode only #> Warning: Episodes enrol & r2 & r1 have no data #>      C   L   I #> r2 0.6 0.2 0.2 #> r1 0.7 0.3 0.0 prior #>            C   L   I #> r1_prior 0.6 0.2 0.2 #> r2_prior 0.7 0.3 0.0   # Prior is returned when all data are missing y_missing <- list(enrol = list(m1 = NA), recur = list(m1 = NA)) suppressMessages(compute_posterior(y_missing, fs = list(m1 = c(\"A\" = 1)))) #> Warning: Markers m1 has data on one episode only #> Warning: Episodes enrol & recur have no data #> $marg #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333 #>  #> $joint #>         C         L         I  #> 0.3333333 0.3333333 0.3333333  #>    # Return of the prior re-weighted to the exclusion of recrudescence: suppressMessages(compute_posterior(y_missing, fs = list(m1 = c(\"A\" = 1)),                  MOIs = c(1,2))) #> Warning: Markers m1 has data on one episode only #> Warning: Episodes enrol & recur have no data #> $marg #>       C   L   I #> recur 0 0.5 0.5 #>  #> $joint #>   C   L   I  #> 0.0 0.5 0.5  #>  # (Recrudescing parasites are clones of previous blood-stage parasites. The # Pv3R model assumes no within-host de-novo mutations and perfect allele # detection. As such, recrudescence is incompatible with an MOI increase on # the preceding infection.)   # Beware provision of unpaired data: the prior is not necessarily returned; # for more details, see link above to \"Understand posterior estimates\" y <- list(list(m1 = c('1', '2')), list(m1 = NA)) fs <- list(m1 = c('1' = 0.5, '2' = 0.5)) suppressMessages(compute_posterior(y, fs))$marg #> Warning: Markers m1 has data on one episode only #> Warning:  #>              C         L         I #> [1,] 0.3292683 0.3414634 0.3292683"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine multiplicities of infection (MOIs) — determine_MOIs","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"Calculates MOI episode based allelic diversity across markers.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"","code":"determine_MOIs(y, return.names = FALSE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"y List lists encoding allelic data; see compute_posterior details. outer list contains episodes chronological order. inner list contains named markers per episode. marker, one must specify allelic vector: set distinct alleles detected marker; NA marker data missing. return.names Logical; TRUE y named episodes, episode names returned.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"Numeric vector containing one MOI per episode, MOI representing maximum number alleles observed marker per episode.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"given episode, MOI maximum number distinct alleles observed marker within episode. MOIs default used compute_posterior.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"","code":"y <- list(enrol = list(m1 = c(\"A\", \"B\"), m2 = c(\"A\"), m3 = c(\"C\")),           recur = list(m1 = c(\"B\"), m2 = c(\"B\", \"C\"), m3 = c(\"A\", \"B\", \"C\"))) determine_MOIs(y) # returns c(2, 3) #> [1] 2 3"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":null,"dir":"Reference","previous_headings":"","what":"Enumerate relationship graphs (RGs) — enumerate_RGs","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"RG graph per-person parasite haploid genotypes (vertex), edges clone sibling genotypes. Valid RGs satisfy: Subgraphs induced clone edges cluster graphs. Subgraphs induced clone plus sibling edges cluster graphs. Clone edges link genotypes different episodes.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"","code":"enumerate_RGs(MOIs, igraph = TRUE, progress.bar = TRUE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"MOIs Vector per-episode multiplicities infection (MOIs), .e., numbers vertices per episode. igraph Logical; returns RGs igraph objects (default TRUE). progress.bar Logical; show progress bar (default TRUE).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"list RGs. igraph = FALSE, RG list length four : clone List vectors encoding genotypes per clonal cell. clone.vec Numeric vector clonal cell membership genotype. sib List vectors encoding clonal cells per sibling cell. sib.vec Numeric vector sibling cell membership clonal cell. igraph = TRUE (default), RG encoded igraph object (see RG_to_igraph).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"RGs generated enumerating nested set partitions specific constraints; see vignette(\"enumerate\"). nested set parition RG. Clone edges induce cluster graph, equivalent partition genotypes, intra-episode clones allowed. Sibling edges refine clone partition, constraints (intra-episode siblings allowed). nested set partition encoded list. partition represented list vectors (either clone sib) membership vector (either clone.vec sib.vec). default, RG encoded list converted igraph object.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"","code":"graphs <- enumerate_RGs(c(2, 1, 2)) # nine graphs #> Number of valid relationship graphs (RGs) is 250 #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> = #> |"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":null,"dir":"Reference","previous_headings":"","what":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"posterior mean multinomial-Dirichlet model uniform prior fit data allele prevalence initial episodes ys_VHX_BPD. model fit allele prevalence (observed) allele frequency ( requires integrating-unknown multiplicities infection) liable underestimate frequencies common alleles overestimate rare detected alleles.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"","code":"fs_VHX_BPD"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"list nine markers; marker named vector allele frequencies sum one.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"https://github.com/jwatowatson/RecurrentVivax/blob/master/RData/GeneticModel/MS_data_PooledAnalysis.RData https://github.com/aimeertaylor/Pv3Rs/blob/main/data-raw/fs_VHX_BPD.R","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/maxima.html","id":null,"dir":"Reference","previous_headings":"","what":"Upper bounds on posterior probabilities — maxima","title":"Upper bounds on posterior probabilities — maxima","text":"Upper bounds posterior probabilities 1st-recurrence recrudescence reinfection (rows) various MOI vectors (columns) sum eight. #' upper bounds feature vignette(\"understand-graph-prior \") vignette(\"intra-episode-siblings\"). single recurrence (MOI vectors length two), upper bounds induced prior. one recurrence (MOI vectors length three ), upper bounds assume first recurrence data; bounds valid monoclonal episodes; see XXX. Two upper bounds recurrence state reported: one summation graphs includes graphs cliques three intra-episode siblings, another summation graphs excludes graphs cliques three intra-episode siblings. Since graphs cliques three intra-episode siblings apply MOI vectors include MOIs three , two bounds differ MOI vectors include MOIs three ; see Examples.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/maxima.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Upper bounds on posterior probabilities — maxima","text":"","code":"maxima"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/maxima.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Upper bounds on posterior probabilities — maxima","text":"matrix 4 rows 247 columns: C_with Row name; upper bound posterior probability recrudescence summation includes graphs cliques three intra-episode siblings. C_wout Row name; upper bound posterior probability recrudescence summation excludes graphs cliques three intra-episode siblings. I_with Row name; upper bound posterior probability reinfection summation includes graphs cliques three intra-episode siblings. I_wout Row name; upper bound posterior probability reinfection summation excludes graphs cliques three intra-episode siblings. 11 Column name; MOI vector (1, 1). 12 Column name; MOI vector (1, 2). 11111111 Column name; MOI vector (1, 1, 1, 1, 1, 1, 1, 1).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/maxima.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Upper bounds on posterior probabilities — maxima","text":"https://github.com/aimeertaylor/Pv3Rs/blob/main/data-raw/maxima.R","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/maxima.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Upper bounds on posterior probabilities — maxima","text":"","code":"# Convert column names to MOI character vectors MOIvec <- strsplit(colnames(maxima), split = \"\")  # Get MOI vectors with MOIs that exceed two Exceed2 <- sapply(MOIvec, function(x) any(as.numeric(x) > 2))  # Compare reinfection upper bounds with and with summation for MOI vectors that exclude # and include MOIs greater than two all(maxima[\"I_with\", !Exceed2] == maxima[\"I_wout\", !Exceed2]) #> [1] TRUE any(maxima[\"I_with\", Exceed2] == maxima[\"I_wout\", Exceed2]) #> [1] FALSE"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a relationship graph (RG) — plot_RG","title":"Plot a relationship graph (RG) — plot_RG","text":"function wrapper around plot.igraph, written group parasite genotypes episode spatially using vertex colour (specifically, parasite genotypes within episodes vertically distributed horizontal jitter layout..group TRUE (default), equicolored), ensure clone sibling edges plotted using different line types.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a relationship graph (RG) — plot_RG","text":"","code":"plot_RG(   RG,   layout.by.group = TRUE,   vertex.palette = \"Set2\",   edge.lty = c(sibling = \"dashed\", clone = \"solid\"),   edge.col = c(sibling = \"black\", clone = \"black\"),   edge.width = 1.5,   ... )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a relationship graph (RG) — plot_RG","text":"RG igraph object encoding RG; see RG_to_igraph. layout..group Logical; TRUE (default) overrides default layout plot.igraph vertices represent parasite genotypes different episodes distributed horizontally vertices represent genotypes within episodes distributed vertically. vertex.palette character string specifying RColorBrewer palette. Overrides default palette plot.igraph. edge.lty Named vector edge line types corresponding different relationships. edge.col Named vector edge colours corresponding different relationships. edge.width Overrides default edge.width plot.igraph. ... Additional arguments pass plot.igraph, e.g., edge.curved.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"provenance","dir":"Reference","previous_headings":"","what":"Provenance","title":"Plot a relationship graph (RG) — plot_RG","text":"function adapted plot_Vivax_model https://github.com/jwatowatson/RecurrentVivax/blob/master/Genetic_Model/iGraph_functions.R.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a relationship graph (RG) — plot_RG","text":"","code":"RGs <- enumerate_RGs(c(2, 1, 1)) #> Number of valid relationship graphs (RGs) is 48 #> = #> == #> = #> == #> == #> = #> == #> = #> == #> == #> = #> == #> = #> == #> == #> = #> == #> = #> == #> == #> = #> == #> = #> == #> == #> = #> == #> = #> == #> == #> = #> == #> == #> = #> == #> = #> == #> == #> = #> == #> = #> == #> == #> = #> == #> = #> == #> == #> | cpar <- par(no.readonly = TRUE) # record current par before changing par(mfrow = c(3, 4), mar = c(0.1, 0.1, 0.1, 0.1)) for (i in 12:23) {   plot_RG(RGs[[i]],   edge.col = c(sibling = \"gray\", clone = \"black\"),   edge.lty = c(sibling = \"dotted\", clone = \"solid\"),   edge.curved = 0.1)   box() }  par(cpar) # reset par"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots the data — plot_data","title":"Plots the data — plot_data","text":"Plots allelic data grid coloured rectangles.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots the data — plot_data","text":"","code":"plot_data(   ys,   fs = NULL,   person.vert = FALSE,   mar = c(1.5, 3.5, 1.5, 1),   gridlines = TRUE,   palette = RColorBrewer::brewer.pal(12, \"Paired\"),   marker.annotate = TRUE,   legend.lab = \"Allele frequencies\",   legend.line = 0.2,   legend.ylim = c(0.05, 0.2),   cex.maj = 0.7,   cex.min = 0.5,   cex.text = 0.5,   x.line = 0.2,   y.line = 2.5 )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots the data — plot_data","text":"ys Nested list per-person, per-episode, per-marker allelic data; see Examples compute_posterior() expected per-person structure. fs per-marker list numeric vectors allele frequencies. NULL (default), alleles present ys shown legend, per-marker alleles represented equally. colour scheme adaptive, allele may different colours given different ys. fs specified, alleles fs feature legend areas proportional allele frequencies, common alleles occupy larger areas rarer alleles. Specify fs fix allele colour scheme across plots different ys. person.vert Logical. TRUE (default), person IDs printed vertically; otherwise, printed horizontally. mar Vector numbers lines margin main plot; see mar entry par. gridlines Logical. true (default), white grid lines separating people markers drawn. palette Colour palette alleles, see Value section brewer.pal. Generally, colours interpolated: marker d possible alleles, colours used 1/(d+1), ..., d/(d+1) quantiles palette ensure markers different allele counts use different colours. marker.annotate Logical. true (default), names alleles printed top colours legend. legend.lab Label axis legend. Defaults \"Allele frequencies\". Set NA omit label; , consider adjusting legend.ylim use plotting space. legend.line Distance (character heights) colour bar legend label (defaults 1.5). legend.ylim Vector specifying y-coordinate limits legend device coordinates (0 1). Defaults c(0.05, 0.2). cex.maj Numeric; font scaling major axis labels. cex.min Numeric; font scaling minor axis labels. cex.text Numeric; font scaling allele labels. x.line Distance top x-axis x-axis label, defaults 0.2. y.line Distance left y-axis y-axis label, defaults 2.5.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plots the data — plot_data","text":"function plots alleles (colours), observed different episodes (columns), different markers (rows), episodes grouped person. Per-person episodes plotted left right chronological order. multiple alleles detected marker within episode, corresponding grid element subdivided vertically different colours. default, markers ordered lexicographically. fs provided, markers ordered match order within fs. legend depicts alleles marker vertical order main plot. default colour scheme adaptive, designed visually differentiate alleles clearly possible maximizing hue contrast within qualitative palette. Interpolation used make different colour palettes markers different numbers possible alleles. names alleles printed top colours marker.annotate set TRUE.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots the data — plot_data","text":"","code":"# Plot example Plasmodium vivax data set mar <- c(2, 3.5, 1.5, 1) # extra vertical margin for vertical person labels plot_data(ys = ys_VHX_BPD, person.vert = TRUE, mar = mar, legend.lab = NA)  plot_data(ys = ys_VHX_BPD, person.vert = TRUE, mar = mar, legend.lab = NA,           fs = fs_VHX_BPD)  plot_data(ys = ys_VHX_BPD, person.vert = TRUE, mar = mar, legend.lab = NA,           fs = fs_VHX_BPD, marker.annotate = FALSE)   # Demonstrating the adaptive nature of the colour scheme: ys <- ys_VHX_BPD[\"VHX_52\"] # A single person plot_data(ys, fs = fs_VHX_BPD, marker.annotate = FALSE) # Colours match above  plot_data(ys) # Colours and the legend adapt to alleles detected in VHX_52"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots a 2D simplex — plot_simplex","title":"Plots a 2D simplex — plot_simplex","text":"Plots 2D simplex (triangle unit sides centered origin) onto per-recurrence posterior probabilities recrudescence, relapse, reinfection (probability triplet summing one) can projected; see project2D() Examples .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots a 2D simplex — plot_simplex","text":"","code":"plot_simplex(   v.labels = c(\"Recrudescence\", \"Relapse\", \"Reinfection\"),   v.cutoff = 0.5,   v.colours = c(\"yellow\", \"purple\", \"red\"),   plot.tri = TRUE,   p.coords = NULL,   p.labels = rownames(p.coords),   p.labels.pos = 3,   ... )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots a 2D simplex — plot_simplex","text":"v.labels Vertex labels anticlockwise top (default: \"Recrudescence\", \"Relapse\", \"Reinfection\"). NULL, vertices labelled. v.cutoff Number 0.5 1 separates lower vs higher probability regions. Use caution recrudescence reinfection classification; see \"Understand posterior estimates\". v.colours Vertex colours anticlockwise top. plot.tri Logical; draws triangular boundary TRUE (default). p.coords Matrix 3D simplex coordinates (e.g., per-recurrence probabilities recrudescence, relapse reinfection), one vector 3D coordinates per row, row projected onto 2D coordinates using project2D() plotted single simplex point using graphics::points(). user provides vector encoding probability triplet summing one, converted matrix one row. p.labels Labels points p.coords (default row names p.coords) labels NA. p.labels.pos Position p.labels: 1 = , 2 = left, 3 = (default) 4 = right. Can single value vector. ... Additional parameters passed graphics::points().","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots a 2D simplex — plot_simplex","text":"","code":"# Plot 2D simplex plot_simplex(p.coords = diag(3),              p.labels = c(\"(1,0,0)\", \"(0,1,0)\", \"(0,0,1)\"),              p.labels.pos = c(1,3,3))   # ============================================================================== # Given data on an enrollment episode and a recurrence, # compute the posterior probabilities of the 3Rs and plot the deviation of the # posterior from the prior # ==============================================================================  # Some data: y <- list(list(m1 = c('a', 'b'), m2 = c('c', 'd')), # Enrollment episode           list(m1 = c('a'), m2 = c('c'))) # Recurrent episode  # Some allele frequencies: fs <- list(m1 = setNames(c(0.4, 0.6), c('a', 'b')),            m2 = setNames(c(0.2, 0.8), c('c', 'd')))  # A vector of prior probabilities: prior <- array(c(0.2, 0.3, 0.5), dim = c(1,3),                dimnames = list(NULL, c(\"C\", \"L\", \"I\")))  # Compute posterior probabilities post <- compute_posterior(y, fs, prior) #> Number of valid relationship graphs (RGs) is 9 #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ========= #> | #> Computing log p(Y|RG) for 9 RGs #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ========= #> | #> Finding log-likelihood of each vector of recurrence states #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ======== #> ========= #> ========= #> | #>   # Plot simplex with the prior and posterior plot_simplex(p.coords = rbind(prior, post$marg),              p.labels = c(\"Prior\", \"Posterior\"),              pch = 20)  # Add the deviation between the prior and posterior: requires obtaining 2D # coordinates manually xy_prior <- project2D(as.vector(prior)) xy_post <- project2D(as.vector(post$marg)) arrows(x0 = xy_prior[\"x\"], x1 = xy_post[\"x\"],        y0 = xy_prior[\"y\"], y1 = xy_post[\"y\"], length = 0.1)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":null,"dir":"Reference","previous_headings":"","what":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"Project three probabilities sum one (e.g., per-recurrence probabilities recrudescence, relapse reinfection) onto coordinates 2D simplex centred origin (.e., triangle centred (0,0) unit-length sides).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"","code":"project2D(v)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"v numeric vector three numbers zero one sum one.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"numeric vector two coordinates can used plot probability vector v origin-centred 2D simplex.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"top, left, right vertices 2D simplex correspond first, second third entries v, respectively. probability proportional distance point simplex side opposite corresponding probability; see Examples plot_simplex() details.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"","code":"probabilities_of_v1_v2_v3 <- c(0.75,0.20,0.05) coordinates <- project2D(v = probabilities_of_v1_v2_v3)  # Plot probability vector on 2D simplex plot_simplex(v.labels = c(\"v1\", \"v2\", \"v3\")) #> NULL points(x = coordinates[1], y = coordinates[2], pch = 20)  # Plot the distances that represent probabilities # get vertices, get points on edges by orthogonal projection, plot arrows v <- apply(matrix(c(1,0,0,0,1,0,0,0,1), nrow = 3), 1, project2D) p3 <- v[,1] + sum((coordinates - v[,1]) * (v[,2] - v[,1])) * (v[,2] - v[,1]) p1 <- v[,2] + sum((coordinates - v[,2]) * (v[,3] - v[,2])) * (v[,3] - v[,2]) p2 <- v[,3] + sum((coordinates - v[,3]) * (v[,1] - v[,3])) * (v[,1] - v[,3]) arrows(x0 = coordinates[1], y0 = coordinates[2], x1 = p1[1], y1 = p1[2], length = 0.1) arrows(x0 = coordinates[1], y0 = coordinates[2], x1 = p2[1], y1 = p2[2], length = 0.1) arrows(x0 = coordinates[1], y0 = coordinates[2], x1 = p3[1], y1 = p3[2], length = 0.1)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample a relationship graph (RG) — sample_RG","title":"Sample a relationship graph (RG) — sample_RG","text":"Uses techniques enumerate_RGs sample single RG uniformly. clonal partitions generated, weighted number consistent sibling partitions. clonal partition sampled proportional weight, consistent sibling partition drawn uniformly. resulting nested partition represents RG; see enumerate_RGs details.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample a relationship graph (RG) — sample_RG","text":"","code":"sample_RG(MOIs, igraph = TRUE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample a relationship graph (RG) — sample_RG","text":"MOIs Vector per-episode multiplicities infection (MOIs), .e., numbers vertices per episode. igraph Logical; TRUE (default), returns RG igraph object.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample a relationship graph (RG) — sample_RG","text":"RG encoded either igraph object (default), list; see enumerate_RGs details.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample a relationship graph (RG) — sample_RG","text":"","code":"set.seed(1) RG <- sample_RG(c(3, 2)) plot_RG(RG)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Plasmodium vivax data — ys_VHX_BPD","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"Previously-published microsatellite data P. vivax parasites extracted study participants enrolled Best Primaquine Dose (BPD) Vivax History (VHX) trials; see Taylor & Watson et al. 2019 details genetic data; details trials, see Chu et al. 2018a Chu et al. 2018b.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"","code":"ys_VHX_BPD"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"list 217 study participants; study participant, list one episodes; episode, list three microsatellite markers; marker, vector observed alleles (repeat lengths). example: BPD_103 Study participant identifier: study participant 103 BPD trial BPD_103_1 Episode identifier: episode one study participant 103 BPD trial PV.3.27 Marker identifier: P. vivax 3.27 18 Allele identifier: 18 repeat lengths","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"https://github.com/jwatowatson/RecurrentVivax/blob/master/RData/GeneticModel/MS_data_PooledAnalysis.RData https://github.com/aimeertaylor/Pv3Rs/blob/main/data-raw/ys_VHX_BPD.R","code":""}]
