[{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Institut Pasteur Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/benchmark.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Benchmarking Pv3Rs","text":"","code":"library(Pv3Rs) library(tictoc) library(gtools)  # simulate allele frequencies for one marker sim_fs_single <- function(n_a) {   alleles <- letters[1:n_a] # n_a <= 26   fs_unnamed <- as.vector(rdirichlet(1, alpha = rep(1, n_a)))   setNames(fs_unnamed, alleles) }  # simulate allele frequencies for multiple markers # assumes each marker has the same number of alleles sim_fs <- function(n_m, n_a) {   markers <- paste0(\"m\", 1:n_m) # marker names   n_a_vec <- setNames(rep(n_a, n_m), markers)   lapply(n_a_vec, sim_fs_single) }  # simulate data for one marker, one episode # sample without replacement to match desired MOI, so must have length(fs) >= MOI sim_data_single <- function(fs_single, MOI) {   sample(names(fs_single), MOI, prob=fs_single) }  # simulate data for all markers, all episodes sim_data <- function(MOIs, n_m, n_a) {   fs <- sim_fs(n_m, n_a)   y <- lapply(     MOIs,     function(MOI) lapply(fs, sim_data_single, MOI) # sample data for one episode   )   return(list(y=y, fs=fs)) }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/benchmark.html","id":"runtime-vs-number-of-markers","dir":"Articles","previous_headings":"","what":"Runtime vs number of markers","title":"Benchmarking Pv3Rs","text":"expect runtime compute_posterior scale linearly number markers due likelihood decomposition (Section 3.4 Taylor, Foo & White, 2022). simulate genetic data spanning across 2 episodes MOI 2, vary number markers 50,100,…,40050, 100, \\ldots, 400. marker assumed 8 possible alleles.","code":"set.seed(1) n_markers <- 50*(1:8) n_a <- 8 MOIs <- c(2, 2) n_rep <- 30  data_by_m <- list() for (n_m in n_markers) {   data_by_m[[as.character(n_m)]] <- lapply(     1:n_rep,     function(x) sim_data(MOIs, n_m, n_a)   ) } time_by_m <- list() for (n_m in n_markers) {   time_by_m[[as.character(n_m)]] <- sapply(     data_by_m[[as.character(n_m)]],     function(data) {       tic(\"\")       suppressMessages(compute_posterior(data$y, data$fs))       res <- toc(quiet=TRUE)       res$toc - res$tic     }   ) } max_time <- max(sapply(time_by_m, max)) par(cex=1.0, mar=c(5, 4.5, 2, 1)) plot(   NULL, type=\"n\",    xlim=c(0, 420),    ylim=c(0, max_time*1.05),   xlab=\"Number of markers\",   ylab=\"Runtime (s)\" ) for(n_m in n_markers) {   points(rep(n_m, n_rep), time_by_m[[as.character(n_m)]], pch=20) }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/benchmark.html","id":"runtime-vs-mois","dir":"Articles","previous_headings":"","what":"Runtime vs MOIs","title":"Benchmarking Pv3Rs","text":"number MOIs increase, runtime increases due possibilities allele assignment valid relationship graphs. simulate genetic data consisting 1 marker (8 alleles), spanning 2 episodes various MOI combinations.  Empirically, runtime (note log scale) roughly exponentially scaling respect total MOI. difficult conclude exact growth rate due small range total MOI. Given fixed total MOI, runtime slightly shorter (see printed output total runtime) maximum MOI larger. can explained following observations: larger maximum MOI leads pairs genotypes clones. leads fewer valid relationship graphs enumerate. Allele assignment largest MOI always fixed. smaller minimum MOI leads fewer allele assignment possibilities considered.","code":"set.seed(1) n_m <- 1 n_a <- 8 MOIs_comb <- list() for(MOItot in 3:7) {   for(MOI1 in (MOItot-1):1) {     MOI2 <- MOItot-MOI1     if(MOI1 >= MOI2) MOIs_comb <- c(MOIs_comb, list(c(MOI1, MOI2)))   } } n_rep <- 30  data_by_MOI <- list() for (MOIs in MOIs_comb) {   data_by_MOI[[paste(MOIs, collapse=\",\")]] <- lapply(     1:n_rep,     function(x) sim_data(MOIs, n_m, n_a)   ) } time_by_MOI <- list() for (MOIs in MOIs_comb) {   MOIstr <- paste(MOIs, collapse=\",\")   time_by_MOI[[MOIstr]] <- sapply(     data_by_MOI[[MOIstr]],     function(data) {       tic(\"\")       suppressMessages(compute_posterior(data$y, data$fs))       res <- toc(quiet=TRUE)       res$toc - res$tic     }   ) } min_time <- min(sapply(time_by_MOI, min)) max_time <- max(sapply(time_by_MOI, max)) n <- length(MOIs_comb)  par(cex=1.0, cex.axis=0.8, mar=c(5, 4.5, 2, 1)) plot(   1, 1, type=\"n\",    xlim=c(0.5, n+0.5),    ylim=c(min_time*0.5, max_time*2),   xlab=\"MOIs\",   ylab=\"Runtime (s)\",   xaxt='n', log=\"y\", ) axis(   side=1, at=1:n,   sapply(MOIs_comb, paste, collapse=\",\") )  for(i in 1:n) {   points(rep(i, n_rep), time_by_MOI[[i]], pch=20) }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/benchmark.html","id":"runtime-vs-number-of-episodes","dir":"Articles","previous_headings":"","what":"Runtime vs number of episodes","title":"Benchmarking Pv3Rs","text":"investigate two separate cases: increasing number episodes 1 genotype per episode, increasing number episodes fixed total MOI.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/benchmark.html","id":"one-genotype-per-episode-episodes-with-moi-1","dir":"Articles","previous_headings":"Runtime vs number of episodes","what":"One genotype per episode (episodes with MOI = 1)","title":"Benchmarking Pv3Rs","text":"simulate genetic data consisting one marker (eight alleles), one genotype per episode various numbers episodes.  one genotype per episode, runtime (note log scale) scales super-exponentially respect number episodes (equivalently, total MOI). fact, number relationship graphs nn episodes one genotype per episode given Rn=∑k=1nS(n,k)Bk,R_n = \\sum_{k=1}^n S(n,k)B_k, S(nk)S(n_k) Stirling numbers second kind BkB_k Bell numbers. provide derivation Appendix, also show logRn∼nlogn\\log R_n \\sim n\\log n.","code":"set.seed(1) n_m <- 1 n_a <- 8 n_epis <- 2:7 n_rep <- 30  data_by_epi <- list() for (epi in n_epis) {   data_by_epi[[as.character(epi)]] <- lapply(     1:n_rep,     function(x) sim_data(rep(1, epi), n_m, n_a)   ) } time_by_epi <- list() for (epi in n_epis) {   time_by_epi[[as.character(epi)]] <- sapply(     data_by_epi[[as.character(epi)]],     function(data) {       tic(\"\")       suppressMessages(compute_posterior(data$y, data$fs))       res <- toc(quiet=TRUE)       res$toc - res$tic     }   ) } min_time <- min(sapply(time_by_epi, min)) max_time <- max(sapply(time_by_epi, max))  par(cex=1.0, mar=c(5, 4.5, 2, 1)) plot(   1, 1, type=\"n\",    xlim=c(1.5, 7.5),    ylim=c(min_time*0.5, max_time*2),   xlab=\"Number of monoclonal episodes\",   ylab=\"Runtime (s)\",   log=\"y\", )  for(epi in n_epis) {   points(rep(epi, n_rep), time_by_epi[[as.character(epi)]], pch=20) }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/benchmark.html","id":"fixed-total-moi","dir":"Articles","previous_headings":"Runtime vs number of episodes","what":"Fixed total MOI","title":"Benchmarking Pv3Rs","text":"simulate genetic data consisting one marker (8 alleles), various numbers episodes fixed total MOI seven. See printed output sequence MOIs considered.  total MOI fixed, runtime increase drastically number episodes (note linear scale, log scale). However, episodes still lead valid relationship graphs pairs can clones, explaining increase runtime.","code":"set.seed(1) n_m <- 1 n_a <- 8 maxepi <- 7 # fixed total MOI n_rep <- 30  MOI_fix_comb <- list() for(epi in 2:maxepi) {   m <- maxepi %/% epi   rem <- maxepi %% epi   MOI_fix_comb <- c(MOI_fix_comb, list(c(rep(m+1, rem), rep(m, epi-rem)))) }  data_by_MOI_fix <- list() for (MOIs in MOI_fix_comb) {   data_by_MOI_fix[[paste(MOIs, collapse=\",\")]] <- lapply(     1:n_rep,     function(x) sim_data(MOIs, n_m, n_a)   ) } time_by_MOI_fix <- list() for (MOIs in MOI_fix_comb) {   MOIstr <- paste(MOIs, collapse=\",\")   time_by_MOI_fix[[MOIstr]] <- sapply(     data_by_MOI_fix[[MOIstr]],     function(data) {       tic(\"\")       suppressMessages(compute_posterior(data$y, data$fs))       res <- toc(quiet=TRUE)       res$toc - res$tic     }   ) } min_time <- min(sapply(time_by_MOI_fix, min)) max_time <- max(sapply(time_by_MOI_fix, max))  par(cex=1.0, mar=c(5, 4.5, 2, 1)) plot(   1, 1, type=\"n\",    xlim=c(1.5, maxepi + 0.5),    ylim=c(0, max_time*1.05),   xlab=\"Number of episodes (fixed total MOI)\",   ylab=\"Runtime (s)\", )  for(epi in 2:maxepi) {   points(rep(epi, n_rep), time_by_MOI_fix[[epi-1]], pch=20) }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/benchmark.html","id":"appendix","dir":"Articles","previous_headings":"","what":"Appendix","title":"Benchmarking Pv3Rs","text":"derive formula RnR_n, number relationship graphs nn episodes one genotype per episode, treat relationship graph nested partition. clonal relationships relationship graph induce partition genotypes subsets, genotypes within subset clones . call subset `clonal cell’. sibling relationships relationship graph induce partition clonal cells subsets, two genotypes subset clones must siblings. Recall Stirling numbers second kind S(n,k)S(n,k) count number ways partition nn objects kk subsets, whereas Bell numbers BkB_k count number ways partition kk objects (number subsets). Letting kk denote number clonal cells, Rn=∑k=1nS(n,k)Bk.R_n = \\sum_{k=1}^n S(n,k)B_k. establish asymptotics RnR_n, first note Rn≥S(n,n)Bn=BnR_n \\ge S(n,n)B_n = B_n. well known logBn∼nlogn\\log B_n \\sim n\\log n. additionally Rn≤nnR_n \\le n^n, follows logRn∼nlogn\\log R_n \\sim n\\log n. rest appendix devoted proving Rn≤nnR_n \\le n^n indeed true. Let ℋn\\mathcal{H}_n set functions hh map elements {1,…,n}\\{1,\\ldots,n\\} {1,…,n}\\{1,\\ldots,n\\}. Since |ℋn|=nn|\\mathcal{H}_n|=n^n, suffices show injection set relationship graphs (nn genotypes) ℋn\\mathcal{H}_n. Consider following mapping relationship graph function hh: Given relationship graph, label genotypes 11 nn, label clonal cells 11 kk. k′=1,…,kk'=1,\\ldots,k, let ck′c_{k'} denote smallest genotype label clonal cell k′k'. genotype ii clonal cell k′k' ck′c_{k'}, define h()=ck′h()=c_{k'}. remains define values h(c1),…,h(ck)h(c_1),\\ldots,h(c_k). sibling relationships induce partition {1,…,k}\\{1,\\ldots,k\\} subsets clonal cells. Let {x1,…,xm}\\{x_1,\\ldots,x_m\\} subset, 1≤x1≤⋯≤xm≤k1\\le x_1 \\le \\cdots \\le x_m\\le k. m′=1,…,mm'=1,\\ldots,m, define h(cxm′)=cxm′+1h(c_{x_{m'}})=c_{x_{m'+1}}, subscripts xx taken modulo mm. repeat subsets partition induced sibling relationships, completes definition mapping. Informally, select one genotype clonal cell representative. function hh maps non-representative genotypes corresponding representatives, maps representative genotypes representative genotypes, subset induced sibling relationships corresponds cycle induced hh. remains show mapping indeed injection. Consider two different relationship graphs g1g_1 g2g_2, corresponding functions h1h_1 h2h_2 mapping . seek show h1≠h2h_1\\neq h_2. Suppose genotypes ii ′' different relationship g1g_1 g2g_2. suffices consider following two cases: Case 1: Genotypes ii ′' strangers one g1g_1 g2g_2, graph. Given function hh obtained mapping relationship graph genotype jj, let sink(j;h)\\textrm{sink}(j;h) denote set genotype labels appear infinitely many times sequence (j,h(j),h(h(j)),…)(j,h(j),h(h(j)),\\ldots). follows sink(;h)≠sink(′;h)\\textrm{sink}(;h)\\neq \\textrm{sink}(';h) genotypes ii ′' strangers. Therefore, must h1≠h2h_1\\neq h_2. Case 2: Genotypes ii ′' siblings one g1g_1 g2g_2, clones graph. Given function hh obtained mapping relationship graph genotype jj, let sink1(j;h)\\textrm{sink}_1(j;h) genotype label sink(j;h)\\textrm{sink}(j;h) occurs first sequence (j,h(j),h(h(j)),…)(j,h(j),h(h(j)),\\ldots). follows sink1(;h)=sink1(′;h)\\textrm{sink}_1(;h)= \\textrm{sink}_1(';h) genotypes ii ′' clones (=′=', irrelevant). Therefore, must h1≠h2h_1\\neq h_2. completes proof logRn∼nlogn\\log R_n \\sim n\\log n.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"basic-workflow","dir":"Articles","previous_headings":"","what":"Basic workflow","title":"Demonstrate Pv3Rs usage","text":"begin synthetic example three episodes (episode names optional) three markers (marker names obligatory) whose alleles known frequencies, fs.","code":"y <- list(\"Enrolment\" = list(m1 = c('b','c','d'),                                m2 = c('a','b'),                               m3 = c('b','c','d')),           \"Recurrence 1\" = list(m1 = c('b','d'),                                  m2 = c('a'),                                  m3 = c('a','b')),           \"Recurrence 2\" = list(m1 = c('d'),                                  m2 = c('a'),                                  m3 = c('a')))  fs <- list(m1 = c(a = 0.27, b = 0.35, c = 0.18, d = 0.20),            m2 = c(a = 0.78, b = 0.14, c = 0.07, d = 0.01),            m3 = c(a = 0.21, b = 0.45, c = 0.26, d = 0.08))"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"plot-data","dir":"Articles","previous_headings":"Basic workflow","what":"1) Plot data","title":"Demonstrate Pv3Rs usage","text":"plot data using plot_data().  marker, different colours represent different alleles. legend main grid shows per-marker allele frequencies via colour proportions, one row per marker, ordered main grid; e.g., d m2 rare. parsimonious MOI estimates compatible data, 3, 2, 1, computed using determine_MOIs(). total genotype count (sum MOIs) 6. Aside synthetic example, markers quart-allelic, imposing low upper bounds MOI estimates based maximum per-marker allele counts. diverse markers recommended MOI estimation recurrence state inference.","code":"plot_data(ys = list(\"Participant data\" = y), fs = fs)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"compute-recurrence-state-posterior-probabilities","dir":"Articles","previous_headings":"Basic workflow","what":"2) Compute recurrence state posterior probabilities","title":"Demonstrate Pv3Rs usage","text":"bulk computational time lies computing log-likelihoods graphs relationships genotypes. number graphs depends MOIs. default, compute_posterior uses MOI estimates generated determine_MOIs. Aside recommend running compute_posterior() data whose total genotype count (sum MOIs) exceeds eight. said, encoded hard limit. experience, possible, long, generate posterior probabilities using data total genotype count 10; 10, calls compute_posterior() liable cause memory-use problems fail. call compute_posterior() specify prior, default three recurrence states assumed equally likely per recurrence. Posterior probabilities recurrent state sequences (C recrudescence, L relapse, reinfection) stored post$joint. , find likely sequence recurrence states IC posterior probability 0.4568: Per-recurrence posterior probabilities recrudescence C, relapse L, reinfection stored post$marg. refer per-recurrence probabilities marg (shorthand marginal) computed simply summing state sequence probabilities. example, probability L Recurrence 1 sum probabilities LC, LL LI:","code":"post <- compute_posterior(y, fs) #> Number of valid relationship graphs (RGs) is 1315 #> =============================================================================| #> Computing log p(Y|RG) for 1315 RGs #> =============================================================================| #> Finding log-likelihood of each vector of recurrence states #> =============================================================================| sort(post$joint, decreasing = T) #>         IC         LC         IL         LL         II         LI         CC  #> 0.45682305 0.21338194 0.15385932 0.08501504 0.05986209 0.03105856 0.00000000  #>         CL         CI  #> 0.00000000 0.00000000 post$marg #>                     C         L          I #> Recurrence 1 0.000000 0.3294555 0.67054446 #> Recurrence 2 0.670205 0.2388744 0.09092065 post$joint[\"LC\"] + post$joint[\"LL\"] + post$joint[\"LI\"] #>        LC  #> 0.3294555"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"plot-per-recurrence-probabilities","dir":"Articles","previous_headings":"Basic workflow","what":"3) Plot per-recurrence probabilities","title":"Demonstrate Pv3Rs usage","text":"Per-recurrence posterior probabilities plotted simplex using plot_simplex().  point yellow region likely recrudescence posterior probability greater 0.5 (falls bright yellow region); point red region likely reinfection posterior probability greater 0.5 (falls bright red region).","code":"par(mar = rep(0.1,4)) p.coords <- rbind(post$marg, Prior = rep(1/3, 3)) plot_simplex(p.coords = p.coords, pch = 20)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"exploration-of-relationship-graphs","dir":"Articles","previous_headings":"","what":"Exploration of relationship graphs","title":"Demonstrate Pv3Rs usage","text":"explore relationship graphs (RGs) log-likelihoods, set return.RG return.logp TRUE. recover posterior . compute time longer: compute posterior, summations per-marker allelic assignments equivalent within-episode genotype permutations redundant. , default, compute_posterior() sum , conserving memory compute time. exploitation permutation symmetry requires scheme choose single representative among permutations otherwise equivalent. compute meaningful graph likelihood values (values depend representative-choosing scheme), permutations summed return.logp = TRUE, increasing compute time, especially MOIs large. Also, user-specified MOIs exceed determine_MOIs(), permutations summed representative-choosing scheme complicated. log-likelihood relationship graph returned. plot relationship graph(s) largest likelihood. example, two graphs maximum likelihood; isomorphic within-episode genotype permutations.  Using log likelihoods, can also find equivalence class data probable relationship graphs class summed .  Important considerations maximum-likelihood graph(s) might equivalence class data probable relationship graphs class summed (true example). maximum-likelihood graph(s) might incompatible maximum-posterior state sequence, (true example; recall -likely sequence IC). graphs maximum-likelihood equivalence class might incompatible maximum-posterior state sequence (true example; class largest likelihood contains graphs sibling edges incompatible IC).","code":"post <- compute_posterior(y, fs, return.RG = TRUE, return.logp = TRUE) #> Number of valid relationship graphs (RGs) is 1315 #> =============================================================================| #> Computing log p(Y|RG) for 1315 RGs #> =============================================================================| #> Finding log-likelihood of each vector of recurrence states #> =============================================================================| sort(post$joint, decreasing = T) #>         IC         LC         IL         LL         II         LI         CC  #> 0.45682305 0.21338194 0.15385932 0.08501504 0.05986209 0.03105856 0.00000000  #>         CL         CI  #> 0.00000000 0.00000000 # Extract all log likelihoods llikes <- sapply(post$RGs, function(RG) RG$logp)  # Get maximum log likelihood mllikes <- max(llikes)  # Extract the relationship graphs (RGs) with the maximum log likelihood RGs <- post$RGs[which(abs(llikes - mllikes) < .Machine$double.eps^0.5)]  # Plot RGs with maximum log likelihoods par(mar = rep(0.1,4), mfrow = c(1,2)) for(i in 1:length(RGs)) {   plot_RG(RG_to_igraph(RGs[[i]], determine_MOIs(y)), vertex.size = 20)   box() }  # Add a legend legend(\"bottomright\", pch = 21,         pt.bg =  RColorBrewer::brewer.pal(n = 8, \"Set2\") [1:length(y)],         bty = \"n\", legend = names(y), title = \"Episode\") # In the following code, we place two graphs in the same equivalence class if # they share the same likelihood. This is not ideal (two graphs that are not # isomorphic up to permutation could share the same likelihood), but it works # here: the plot shows only isomorphic graphs within the equivalence class.  sorted_llikes <- sort(llikes, decreasing = T) # Sort log likelihoods adj_equal <- abs(diff(sorted_llikes, lag = 1)) < .Machine$double.eps^0.5 # Find matches decr_idxs <- which(adj_equal == FALSE) # Change points: 2, 8, 14, 20, 32, ... class_sizes <- c(decr_idxs[1], diff(decr_idxs)) # Number of graphs per class  # log likelihood of representative from each 'equivalence class' (EC) llikes_unique <- sorted_llikes[decr_idxs]  # EC likelihood class_ps <- exp(llikes_unique)*class_sizes max_class_p <- which(class_ps == max(class_ps)) # ML EC index  max_idx <- decr_idxs[max_class_p] # Index of last graph in ML EC max_size <- class_sizes[max_class_p] # Number of graphs in ML EC  # Plot all graphs within the ML EC  par(mar = rep(0.1,4), mfrow = c(3,4)) RG_order <- order(llikes, decreasing = T) # order RGs by logl for(i in (max_idx-max_size+1):max_idx) { # EC consists of the RGs with logl rank 21-32   RG <- post$RGs[[RG_order[i]]]   RG_igraph <- RG_to_igraph(RG, determine_MOIs(y))   plot_RG(RG_igraph, vertex.size = 25, vertex.label = NA)   box() }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/intra-episode-siblings.html","id":"example-of-a-group-of-four-intra-episode-siblings-collapsing-to-two","dir":"Articles","previous_headings":"","what":"Example of a group of four intra-episode siblings collapsing to two","title":"Understand intra-episode siblings","text":"demonstrating intra-episode sibling groups collapse pairs, write function simulate data 200 markers user-specified allelic richness (marker cardinality) enrolment episode comprising stranger plus group four siblings, two one oocyst, two another, drawing two unrelated parental genotypes, recurrence one sibling. Technically, enrolment episode contains five genetically distinct genotypes thus MOI five. However, MOI estimates based maximum per-marker allele counts three one markers polyallelic: two one markers biallelic: Suppose estimate MOIs 3 1 biallelic data using external software exploits heteroallelic marker counts, input external estimates compute_posterior(). Providing data simulated large number markers (200 ), recover almost exactly posterior probabilities using polyallelic data without user-specified MOIs biallelic data user-specified MOIs three one However, following graphs, cliques three intra-episode siblings, zero likelihood given polyallelic data:  Whereas, relationships non-zero likelihood given biallelic data:","code":"simulate_data <- function(marker_cardinality){      # Magic numbers / quantities   set.seed(5) # For reproducibility   n_markers <- 200 # Number of markers   n_strangers <- 3 # Number of stranger parasites   n_oocysts <- 2 # Number of oocysts to draw from      # Derived quantities   alleles <- letters[1:marker_cardinality]   markers <- paste0(\"m\", 1:n_markers) # Marker names      # Uniform allele frequencies    fs <- sapply(markers, simplify = FALSE,                 function(m) setNames(rep(1/marker_cardinality, marker_cardinality), alleles))      # Sample strangers   strangers <- sapply(1:n_strangers, function(i) {     sapply(markers, function(t) sample(names(fs[[t]]), size = 1, prob = fs[[t]]))   })      # Designate strangers   parents <- strangers[, 1:2]      # Map the markers to chromosomes. Assume equally sized chromosomes — reasonable   # if and only if we later assume an equal number of crossovers per chromosome   chrs_per_marker <- round(seq(0.51, 14.5, length.out = n_markers))      # Sample parental allocations dependently per-oocyst    cs <- lapply(1:n_oocysts, function(o) recombine_parent_ids(chrs_per_marker))      # Construct children from parental allocations    all_children <- lapply(1:n_oocysts, function(o) {     oocyst_chidren <- sapply(1:n_markers, function(i) {       sapply(1:ncol(cs[[o]]), function(j) parents[i,cs[[o]][i,j]])     })     colnames(oocyst_chidren) <- markers     return(oocyst_chidren)   })      # Make enrolment infection   enrol <- apply(rbind(all_children[[1]][1:2,],                         all_children[[2]][1:2,],                         strangers[,3]), 2, unique, simplify = F)      # Make paired data   data <- list(enrol = enrol, recur = as.list(all_children[[1]][1,]))      return(list(data = data, fs = fs)) } polyallelic <- simulate_data(10)  determine_MOIs(polyallelic$data) #> [1] 3 1 biallelic <- simulate_data(2)  determine_MOIs(biallelic$data) #> [1] 2 1 ppost <- suppressMessages(compute_posterior(y = polyallelic$data,                                              fs = polyallelic$fs,                                              return.logp = T)) bpost <- suppressMessages(compute_posterior(y = biallelic$data,                                              fs = biallelic$fs,                                              MOIs = c(3,1), return.logp = T))  ppost$marg #>               C         L             I #> recur 0.6666667 0.3333333 2.708985e-116 bpost$marg #>               C         L            I #> recur 0.6666663 0.3333337 4.625927e-18 llikes <- sapply(bpost$RGs, function(RG) RG$logp) # Extract log likelihoods any(is.infinite(llikes)) # Are there any minus infinity log likelihoods? #> [1] FALSE"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/intra-episode-siblings.html","id":"contribution-to-upper-bounds","dir":"Articles","previous_headings":"","what":"Contribution to upper bounds","title":"Understand intra-episode siblings","text":"summation graphs cliques three siblings possibly redundant given graphs practical support. Even graphs zero likelihood, contribute maximum probabilities recrudescence / reinfection conditionally uniform prior graphs. However, upper bounds probability reinfection / recrudescence given single recurrence contribution small, especially reinfection:   recrudescence, 3 MOI vectors (circled plot ) result absolute difference greater 0.0175. feature large MOIs (MOI vectors 5 2 , 6 2 , 7 1 ) thus whose graph spaces include graphs largest cliques intra-episode siblings. contribution likely even smaller vectors three MOIs computationally feasible Pv3Rs, constituent MOIs necessarily less 7 (recall computationally feasible MOI vectors sum eight).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"summary-of-contents","dir":"Articles","previous_headings":"","what":"Summary of contents","title":"Understand posterior probabilities","text":"start documenting output compute_posterior() statistical model underpinning well specified Data missing Data uninformative Data limited one episode Data incomparable across episodes Data limited one marker Data limited two markers Given data many markers, show well specified model maximum probabilities recrudescence reinfection depend Per-episode multiplicities infections Episode count Position recurrence sequence episodes thus comment dependencies impact interpretation uncertainty given probable uncertain recrudescence reinfection. Finally, summarise results output compute_posterior() model misspecified Meiotic siblings Half siblings Parent-child-like siblings detailed results sibling misspecification can found inRelationshipStudy. yet characterised model misspecification due genotyping errors stranger parasites elevated relatedness: - Genotyping errors likely cause misspecification recrudescence relapse misspecification relapse reinfection. - Stranger parasites related insofar population related average largely accounted : Allele frequency estimates encode population-level average relatedness locus--locus [Mehra et al. 2025]. Allele frequency estimates plugged statistical model underpinning Pv3Rs. Providing computed sample drawn parasite population trial participants also draw, need compensate population-level average relatedness locus--locus. However, strong inter-locus dependence (linkage disequilibrium) generate overconfident posterior probabilities. - Stranger parasites related due population structure (e.g., proximity space time) likely lead misclassification reinfection relapse / recrudescence. view, recurrence classification presence population structure best understood using complementary population-genetic sensitivity analyses (e.g., identity--descent networks).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"missing","dir":"Articles","previous_headings":"","what":"Missing data","title":"Understand posterior probabilities","text":"data entirely missing, compute_posterior() returns prior. data missing user provides MOIs incompatible recrudescence, compute_posterior() returns prior re-weighted exclusion recrudescence.","code":"fs = list(m1 = c(\"A\" = 0.5, \"B\" = 0.5)) # Allele frequencies y = list(enrol = list(m1 = NA), recur = list(m1 = NA)) # Missing data suppressMessages(compute_posterior(y, fs))$marg # Posterior #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333 suppressMessages(compute_posterior(y, fs, MOIs = c(1,2)))$marg  #>       C   L   I #> recur 0 0.5 0.5"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"uniformative","dir":"Articles","previous_headings":"","what":"Uniformative data","title":"Understand posterior probabilities","text":"data uninformative genetic diversity, compute_posterior() returns prior.","code":"fs = list(m1 = c(\"A\" = 1)) # Unit allele frequency: no genetic diversity y = list(list(m1 = \"A\"), recur = list(m1 = \"A\")) # Data the only viable allele suppressMessages(compute_posterior(y, fs))$marg # Posterior #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333"},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"homoallelic-data-without-user-specified-mois-prior-return","dir":"Articles","previous_headings":"Data on only one episode","what":"Homoallelic data without user-specified MOIs: prior return","title":"Understand posterior probabilities","text":"one episode homoallelic data user specify MOI > 1, compute_posterior() returns prior.","code":"fs = list(m1 = c(\"A\" = 0.5, \"B\" = 0.5)) # Allele frequencies y <- list(enrol = list(m1 = NA), recur1 = list(m1 = \"A\")) # No enrolment data suppressMessages(compute_posterior(y, fs))$marg # Posterior #>                C         L         I #> recur1 0.3333333 0.3333333 0.3333333"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"heteroallelic-data-prior-proximity","dir":"Articles","previous_headings":"Data on only one episode","what":"Heteroallelic data: prior proximity","title":"Understand posterior probabilities","text":"one episode heteroallelic data, MOI model necessarily exceeds one model assumes false alleles. posterior close prior equal data slightly informative: relationship graphs intra-episode siblings, heteroallelic data limit summation identity--descent partitions partitions least two cells episode data. lower bound cell count increases number distinct alleles observed.","code":"# Allele frequencies  fs = list(m1 = c('A' = 0.25, 'B' = 0.25, 'C' = 0.25, 'D' = 0.25))   # MOI at enrolment increases with number of observed alleles:   yMOI2 <- list(enrol = list(m1 = c('A','B')), recur = list(m1 = NA)) yMOI3 <- list(enrol = list(m1 = c('A','B','C')), recur = list(m1 = NA)) yMOI4 <- list(enrol = list(m1 = c('A','B','C','D')), recur = list(m1 = NA)) ys <- list(yMOI2, yMOI3, yMOI4) do.call(rbind, lapply(ys, function(y) {   suppressMessages(compute_posterior(y, fs))$marg }))  #>               C         L         I #> recur 0.3292683 0.3414634 0.3292683 #> recur 0.3260870 0.3478261 0.3260870 #> recur 0.3248359 0.3503282 0.3248359  # MOI increases with external input: MOIs <- list(c(2,1), c(2,2), c(3,2)) # user-specified MOIs y <- list(enrol = list(m1 = c('A','B')), recur = list(m1 = NA)) # Data  do.call(rbind, lapply(MOIs, function(x) {   suppressMessages(compute_posterior(y, fs, MOIs = x))$marg }))  #>               C         L         I #> recur 0.3292683 0.3414634 0.3292683 #> recur 0.3250000 0.3500000 0.3250000 #> recur 0.3334508 0.3330983 0.3334508"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"rare-homoallelic-data-with-user-specified-mois-exceeding-1-prior-departure","dir":"Articles","previous_headings":"Data on only one episode","what":"Rare homoallelic data with user-specified MOIs exceeding 1: prior departure","title":"Understand posterior probabilities","text":"data homoallelic, user specifies MOIs greater one, observed allele rare, posterior departs prior rare intra-episode allelic repeats probable given relationship graphs intra-episode relatedness.  per-graph likelihood appreciable relationship graphs distinct parasite genotypes first episode siblings","code":"y <- list(enrol = list(m1 = 'A'), list(m1 = NA)) # Homoallelic data MOIs <- list(c(2,1), c(3,2), c(5,1)) # Different MOIs with first MOI > 1 fs = list(m1 = c(\"A\" = 0.01, \"B\" = 0.99)) # Rare observed allele"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"incomparable","dir":"Articles","previous_headings":"","what":"Data are incomparable across episodes","title":"Understand posterior probabilities","text":"data multiple episodes common markers across episodes, compute_posterior() behaves similarly data limited one episode: returns prior data homoallelic without user-specified MOIs > 1, output remains close prior data heteroallelic, output departs prior data homoallelic rare user-specified MOIs > 1.","code":"# Allele frequencies fs = list(m1 = c(\"A\" = 0.01, \"B\" = 0.99),            m2 = c(\"A\" = 0.01, \"B\" = 0.99))   # Data with an incomparable homoallelic call y_hom <- list(enrol = list(m1 = \"A\", m2 = NA),                recur = list(m1 = NA, m2 = \"A\"))  # Data with an incomparable heteroallelic call y_het <- list(enrol = list(m1 = c(\"A\", \"B\"), m2 = NA),                recur = list(m1 = NA, m2 = c(\"A\", \"B\")))  suppressMessages(compute_posterior(y_hom,fs))$marg # Prior return  #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333 suppressMessages(compute_posterior(y_het,fs))$marg # Prior proximity #>               C         L         I #> recur 0.3370787 0.3595506 0.3033708 suppressMessages(compute_posterior(y_hom,fs,MOIs=c(2,2)))$marg # Prior departure #>               C         L        I #> recur 0.5142862 0.2183909 0.267323"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"one-marker","dir":"Articles","previous_headings":"","what":"Data on only one marker","title":"Understand posterior probabilities","text":"Given data one marker, output compute_posterior() depends observation type frequencies observed alleles: rare match informative: quashes posterior probability reinfection. partial rare match informative: quashes posterior probability reinfection. match common allele informative: states possible posteriori. partial match common allele informative: states possible posteriori. mismatch informative: quashes posterior probability recrudescence. latter demonstrates sensitivity recrudescence inference assumption model genotyping errors: genotyping error generates single mismatch, posterior probability recrudescence quashed.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"two-markers","dir":"Articles","previous_headings":"","what":"Data on only two markers","title":"Understand posterior probabilities","text":"Adding second consistent observation generally strengthens inference (see arrows entering regions probability > 0.5). exception adding common match common partial match, adds little information (central arrow). mismatch added rare match (diamond), relapse becomes probable state. illustrates multiple-marker requirement relapse inference.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"many-markers","dir":"Articles","previous_headings":"","what":"Data on many markers","title":"Understand posterior probabilities","text":"Given non-zero prior probabilities, data increase number markers, posterior probabilities given recurrence well specified model converge either Relapse posterior probability one data suggest episode interest linked previous episodes regular sibling relationships Recrudescence posterior probability less one data suggest episode interest linked directly preceding episode clonal relationships Reinfection posterior probability less one data suggest episode interest linked previous episodes regular sibling clonal relationships Recrudescence / reinfection probabilities necessarily converge uncertain values genetic data compatible recrudescence / reinfection also compatible relapse.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"posterior-bounds","dir":"Articles","previous_headings":"Data on many markers","what":"Posterior bounds","title":"Understand posterior probabilities","text":"assume priori relationship graphs compatible given recurrence state sequence uniformly distributed, relationship graphs compatible sequences recrudescence / reinfection subset compatible sequences relapse, prior-induced bounds non-marginal posterior probabilities can computed priori function prior recurrence state sequences prior relationship graphs; see Understand graph-prior ramifications. probability mass function uniformly distributed discrete random variable depends size support, prior uniformly distributed graphs (resulting prior-induced posterior bounds) depends size graph space. size space determined size graphs contains, many vertices parasite genotypes within across episodes. , graph size depends number episodes per-episode MOIs, vary across trial participants. Using rare matched mismatched data 100 markers, illustrate prior-induced posterior bounds single recurrence depend per-episode MOIs. also demonstrate maximum marginal probabilities recrudescence / relapse depend episode counts adding recurrences recurrent data. However, maxima rely knowing recurrent data absent first recurrence thus computable priori. start defining variables used repeatedly following code chunks.","code":"marker_count <- 100 # Number of markers ms <- paste0(\"m\", 1:marker_count) # Marker names  all_As <- sapply(ms, function(t) \"A\", simplify = F) # As for all markers all_Bs <- sapply(ms, function(t) \"B\", simplify = F) # Bs for all markers no_data <- sapply(ms, function(t) NA, simplify = F) # NAs for all markers fA <- 0.01 # Frequency of rare allele fB <- 1 - fA # Frequency of common allele fs <- sapply(ms, function(m) c(\"A\"=fA, \"B\"=fB), simplify = FALSE) # Frequencies"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"mois","dir":"Articles","previous_headings":"Data on many markers","what":"Increasing per-episode MOIs","title":"Understand posterior probabilities","text":"posterior probabilities increase increasing graph size, MOIs balanced case recrudescence.","code":"MOIs <- list(c(1,1), c(2,1), c(2,2))  y_match <- list(enrol = all_As, recur = all_As) y_mismatch <- list(enrol = all_As, recur = all_Bs)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"digression-counts-of-intra-episode-siblings","dir":"Articles","previous_headings":"Data on many markers > Increasing per-episode MOIs","what":"Digression: counts of intra-episode siblings","title":"Understand posterior probabilities","text":"increase per-episode MOIs, can increase user-specified MOIs without changing data, can increase allelic diversity data, s.t. MOIs modelled Pv3Rs increase without user-specified MOIs. Either way, get maximum probabilitie, graph likelihoods change:  homoallelic data elevated user-specified MOIs, intra-episode parasites maximum likelihood graphs siblings. heteroallelic data, intra-episode parasites maximum likelihood graphs strangers. One upshot maximum probabilities arbitrarily increased increasing counts intra-episode siblings. Since siblings independent, maxima arguably increase beyond two siblings per episode. Pv3Rs model realistic MOI estimates, groups three siblings effectively treated pairs; see Understand intra-episode siblings. END DIGRESSION","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"epi-count","dir":"Articles","previous_headings":"Data on many markers","what":"Increasing episode counts","title":"Understand posterior probabilities","text":"Recurrences can added without adding data marginal probability first recurrence recrudescence / reinfection depends total number recurrences:  example recrudescence probabilities converge maxima 1, 2, 5 100 markers:  Recall maxima bounds imposed prior: based knowledge recurrent data first recurrence; see Understand graph-prior ramifications.","code":"ys_match <- list(\"1_recurrence\" = list(enrol = all_As,                                         recur1 = all_As),                  \"2_recurrence\" = list(enrol = all_As,                                         recur1 = all_As,                                        recur2 = no_data),                  \"3_recurrence\" = list(enrol = all_As,                                         recur1 = all_As,                                        recur2 = no_data,                                        recur3 = no_data))  ys_mismatch <- list(\"1_recurrence\" = list(enrol = all_As,                                            recur1 = all_Bs),                     \"2_recurrence\" = list(enrol = all_As,                                            recur1 = all_Bs,                                           recur2 = no_data),                     \"3_recurrence\" = list(enrol = all_As,                                            recur1 = all_Bs,                                           recur2 = no_data,                                           recur3 = no_data))"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"position","dir":"Articles","previous_headings":"Data on many markers","what":"Position in a sequence","title":"Understand posterior probabilities","text":"distribution relationship graphs invariant different orderings states sequence (graphs compatible reinfection beginning versus end sequence three episodes, example), position recurrence sequence affects per-recurrence posterior probability. examples also highlight , well-specified model, jointly modelling data across two episodes preferable analysing episodes pairwise. effect position negligible episodes data many markers: Instead, consider sequences episodes observations (Os) episodes data (Ns):","code":"y <- list(enrol = all_As,            recur1 = all_As,            recur2 = all_As,            recur3 = all_As) suppressMessages(compute_posterior(y, fs))$marg #>                C         L            I #> recur1 0.7720588 0.2279412 5.585675e-23 #> recur2 0.7720588 0.2279412 5.316220e-23 #> recur3 0.7720588 0.2279412 5.044004e-23 ys_match <- list(\"NOO\" = list(enrol = no_data,                                recur1 = all_As,                               recur2 = all_As),                  \"ONO\" = list(enrol = all_As,                                recur1 = no_data,                               recur2 = all_As),                  \"OON\" = list(enrol = all_As,                                recur1 = all_As,                               recur2 = no_data))  ys_mismatch <- list(\"NOO\" = list(enrol = no_data,                                   recur1 = all_As,                                  recur2 = all_Bs),                     \"ONO\" = list(enrol = all_As,                                   recur1 = no_data,                                  recur2 = all_Bs),                      \"OON\" = list(enrol = all_As,                                   recur1 = all_Bs,                                  recur2 = no_data))"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"highly-informed-recurrences","dir":"Articles","previous_headings":"Data on many markers > Position in a sequence","what":"Highly informed recurrences","title":"Understand posterior probabilities","text":"first recurrence sequence OON (upward purple 1 triangle) slightly lower probability recrudescence second recurrence sequence NOO (upward green 2 triangle) despite recurrences rare observations match directly preceding episode. first recurrence sequence OON (downward purple 1 triangle) slightly higher probability reinfection second recurrence sequence NOO (downward green 2 triangle) despite recurrences observations mismatch directly preceding episode.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"weakly-and-uninformed-recurrences","dir":"Articles","previous_headings":"Data on many markers > Position in a sequence","what":"Weakly and uninformed recurrences","title":"Understand posterior probabilities","text":"Unsurprisingly, posterior first recurrence sequence NOO close prior (preceding data), likewise second recurrence sequence OON (data). surprisingly, posterior first recurrence sequence ONO close prior, despite data. closer inspection, surprising reasons explained . match data (upward triangles), strong evidence clonal edge episodes one three ONO incompatible recurrence sequences ending reinfection reinfection followed recrudescence, informing strongly second recurrence weakly first recurrence. comparison, strong evidence clonal edge episodes two three NOO incompatible sequences recurrences ending reinfection, informing second recurrence ; likewise, strong evidence clonal edge episodes one two OON incompatible sequences recurrences starting reinfection, informing first recurrence . close inspection upward orange 1 triangle makes intuitive sense: know first recurrence followed second MOI = 1 recurrence clone MOI = 1 enrolment episode, unlikely second recurrence clone drawn new mosquito recrudescence reinfection. Thus, enrolment second recurrence data inform first recurrence, causing posterior deviate prior even though data. explanation mismatch data (downward triangles) sequence ONO similar match data: strong evidence stranger edge episodes one three incompatible double recrudescence, posterior first recurrence (downward orange 1 triangle) deviates prior despite first recurrence data.","code":"epsilon <- .Machine$double.eps # Very small probability names(which(suppressMessages(compute_posterior(y = ys_match[[\"ONO\"]], fs))$joint < epsilon)) #> [1] \"IC\" \"CI\" \"LI\" \"II\" names(which(suppressMessages(compute_posterior(y = ys_match[[\"NOO\"]], fs))$joint < epsilon)) #> [1] \"CI\" \"LI\" \"II\" names(which(suppressMessages(compute_posterior(y = ys_match[[\"OON\"]], fs))$joint < epsilon)) #> [1] \"IC\" \"IL\" \"II\" epsilon <- .Machine$double.eps # Very small probability names(which(suppressMessages(compute_posterior(y = ys_mismatch[[\"ONO\"]], fs))$joint < epsilon)) #> [1] \"CC\" names(which(suppressMessages(compute_posterior(y = ys_mismatch[[\"NOO\"]], fs))$joint < epsilon)) #> [1] \"CC\" \"LC\" \"IC\" names(which(suppressMessages(compute_posterior(y = ys_mismatch[[\"OON\"]], fs))$joint < epsilon)) #> [1] \"CC\" \"CL\" \"CI\""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"uncertainty","dir":"Articles","previous_headings":"","what":"Interpreting uncertainty","title":"Understand posterior probabilities","text":"Uncertain posterior probabilities can uncertain two reasons mutually exclusive: data needed states fully identifiable also important bear mind -illustrated facts , Pv3Rs model, trial participants different per-episode MOIs episode counts different maximum probabilities recrudescence / reinfection. example, use common threshold 0.8 classify probable reinfection assuming recurrence states equally likely priori, can discount priori trail participants single monoclonal recurrence following monoclonal enrolment episode posterior reinfection probabilities never exceed 0.75, even data highly informative reinfection: , given trial participant, probability recrudescence / reinfection depends position within sequence, especially one episodes data.","code":"y <- list(enrol = all_As, recur = all_Bs) fs <- sapply(ms, FUN = function(m) c(\"A\" = 0.5, \"B\" = 0.5), simplify = FALSE)  # Using the default uniform prior on recurrence states suppressMessages(compute_posterior(y, fs))$marg #>       C    L    I #> recur 0 0.25 0.75  # Using a non-uniform prior on recurrence states prior <- as.matrix(data.frame(\"C\" = 0.25, \"L\" = 0.25, \"I\" = 0.5)) suppressMessages(compute_posterior(y, fs, prior))$marg #>       C         L         I #> recur 0 0.1428571 0.8571429"},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"methods","dir":"Articles","previous_headings":"Meiotic siblings","what":"Methods","title":"Understand posterior probabilities","text":"simulated data generated results initial infection containing two three meiotic siblings recurrent stranger clone regular sibling meiotic sibling Posterior probabilities computed assuming recurrence states equally likely priori.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"results","dir":"Articles","previous_headings":"Meiotic siblings","what":"Results","title":"Understand posterior probabilities","text":"initial infection contains two meiotic siblings compute_posterior() well behaved maximum likelihood true relationship graph (shown). Posterior probabilities converge probable reinfection recurrent parasite stranger, probable recrudescence recurrent parasite clone, certain relapse recurrent parasite regular sibling, certain relapse recurrent parasite meiotic sibling.  initial infection contains three meiotic siblings recurrent parasite either stranger clone, posterior probabilities converge correctly probable reinfection probable recrudescence, respectively, maximal values given graphs relationships two, three, parasites initial infection.  Relationship graphs (shown) wrong two reasons: relationship graphs two, three, parasites initial infection two alleles per marker. Although technically incorrect, behaviour arguably desirable; see digression section Data many markers. highest likelihood relationship graphs stranger parasites initial episode prevalence data three four meiotic siblings identical bulk data parents, strangers. can force graphs three distinct parasites initial episode specifying external MOIs. recovers maximum likelihood true relationship graphs. However, correct MOIs unknowable practice: collection siblings two parents can ever diverse two parents. initial infection contains three meiotic siblings recurrent parasite regular meiotic sibling, posterior probabilities converge probable recrudescence maximum likelihood graphs clonal edge sibling relapse, either two stranger parasites initial episode external MOIs specified, three sibling parasites initial episode correct MOIs (unknowable practice) provided externally.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"methods-1","dir":"Articles","previous_headings":"Half siblings","what":"Methods","title":"Understand posterior probabilities","text":"simulated data three half siblings: two initial episode, third recurrence: child parents 1 2 initial episode child parents 1 3 initial episode child parents 2 3 recurrence explored two scenarios: one parental parasites draw allele distribution. Another admixture parent 1 draws alleles disproportionally parents 2 3. admixture scenario improbable. explore worse case scenario: contrived maximally hamper relapse classification.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"results-1","dir":"Articles","previous_headings":"Half siblings","what":"Results","title":"Understand posterior probabilities","text":"general, parental parasites draw allele distribution, frequency certain relapse increases erratically number markers genotyped. particular case three equifrequent alleles per marker, can show theoretically system behaves erratically small perturbation ratio observations (alleles match across three half siblings, alleles different, intra-episode alleles match, inter-episode alleles match) can lead large deviation odds relapse versus reinfection; see Understand half-sibling misspecification. purple, red, green trajectories higher expected 0.5 intra--inter match ratios; moreover, purple trajectory’s intra--inter match ratio consistently exceeds 0.5×log2(25)0.5\\times \\text{log}_2(\\dfrac{2}{5}), condition found theoretically concentrate posterior probability reinfection certain conditions; , see Understand half-sibling misspecification. intra-episode parasites systematically share rare alleles (admixture imbalanced allele frequencies), frequency probable reinfection increases erratically number markers genotyped. scenarios, likelihood true graph siblings within across episodes quashed soon distinct alleles three parents observed given marker. general, parasites draw allele distribution, maximum likelihood graphs two one inter-episode sibling edge. intra-episode parasites systematically share rare alleles, maximum likelihood graph one one intra-episode sibling edge.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"methods-2","dir":"Articles","previous_headings":"Parent-child-like siblings","what":"Methods","title":"Understand posterior probabilities","text":"simulated data three parent-child-like siblings: child selfed parent 1 initial episode child parents 1 2 initial episode child selfed parent 2 recurrence Aside: alternative children selfed parents initial episode equivalent meiotic case three mieotic siblings initial episode prevalence data three meiotic siblings equivalent prevalence data two stranger parents leads probable recrudescence rather certain relapse number markers genotyped. half-siblings, explored two scenarios: one parental parasites draw allele distribution. Another admixture parent 1 draws alleles disproportionally parents 2 3. admixture scenario improbable. explore worse case scenario: contrived maximally hamper relapse classification.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/posterior-probabilities.html","id":"results-2","dir":"Articles","previous_headings":"Parent-child-like siblings","what":"Results","title":"Understand posterior probabilities","text":"parental parasites draw allele distribution, frequency certain relapse increases erratically number markers genotyped.  intra-episode parasites systematically share rare alleles (admixture imbalanced allele frequencies), frequency probable reinfection increases erratically number markers genotyped.  general, parasites draw allele distribution, maximum likelihood graph true graph siblings within across episodes. Meanwhile, intra-episode parasites systematically share rare alleles, maximum likelihood graph one one intra-episode sibling edge.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Aimee Taylor. Author, maintainer. Yong See Foo. Author. Tymoteusz Kwiecinski. Compiler. Duncan Murdoch. Contributor. Mans Magnusson. Contributor. Institut Pasteur. Copyright holder. European Union, Project 101110393. Funder.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Taylor , Foo Y (2025). Pv3Rs: Estimate Cause Recurrent Vivax Malaria using Genetic Data. R package version 0.0.0.9000, https://aimeertaylor.github.io/Pv3Rs/.","code":"@Manual{,   title = {Pv3Rs: Estimate the Cause of Recurrent Vivax Malaria using Genetic Data},   author = {Aimee Taylor and Yong See Foo},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://aimeertaylor.github.io/Pv3Rs/}, }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"pv3rs-","dir":"","previous_headings":"","what":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"R package Plasmodium vivax molecular correction via statistical genetic inference Relapse Recrudescence Reinfection core function, compute_posterior(), computes per-person posterior probabilities relapse, recrudescence, reinfection (recurrence states) using P. vivax genetic data two episodes. fully understand core function, addition reading README entirety pre-print cited , recommend reading vignette(\"demonstrate-usage\", \"Pv3Rs\") Understand posterior probabilities. Two important features: plot_data() visualises genetic data molecular correction, regardless analytical method (e.g., Plasmodium falciparum data intended analysis using match-counting algorithm). plot_simplex() can used visualise per-recurrence probabilities relapse, recrudescence, reinfection, probability triplet summing one.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"please-be-aware-of-the-following-points","dir":"","previous_headings":"","what":"Please be aware of the following points!","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Pv3Rs R package yet peer-reviewed thus liable modification. model described preprint Taylor, Foo & White, 2022, building prototype Taylor & Watson et al. 2019.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"prior-considerations","dir":"","previous_headings":"Please be aware of the following points!","what":"Prior considerations:","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Genetic data modelled using Bayesian model, whose prior ideally informative ([2] priors generated time--event model built James Watson) cause recurrent P. vivax malaria always identifiable genetic data alone: data consistent recurrent parasites relatively unrelated preceding infections, reinfection relapse plausible; meanwhile, data compatible recurrent parasites clones preceding infection, recrudescence relapse plausible. main Pv3Rs function, compute_posterior(), applied P. falciparum setting prior probability relapse zero, genotyping errors, accounted current Pv3Rs model, liable lead misclassification recrudescence reinfection prior probability relapse zero (recrudescence relapse prior probability relapse exceeds zero).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"notable-assumptions-and-limitations","dir":"","previous_headings":"Please be aware of the following points!","what":"Notable assumptions and limitations:","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"model, Pv3Rs makes various assumptions limit capabilities settings.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"mutually-exclusive-recurrent-states","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Mutually exclusive recurrent states","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Recurrence states modelled mutually exclusive, suitable studies participants actively followed frequently detected infections treated extent parasitaemia drops detectable level recurrence, recurrence occurs. studies untreated accumulated infections, outputs may meaningful.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"unmodelled-complexities","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Unmodelled complexities","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"model complexities around molecular correction. example, population structure, including household effects; failure capture low-density clones blood sample limited volume [Snounou & Beck, 1998]; hidden biomass spleen bone marrow [Markus, 2019]. Users must interpret outputs context study methods. example, expect Pv3Rs output probable relapse person reinfected new mosquito parasites recently related caused previous infection, might happen household transmission chains.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"sibling-misspecification","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Sibling misspecification","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Relapsing parasites siblings parasites previous infections can meiotic, parent-child-like, regular half siblings, model sibling parasites regular siblings via following assumptions: Allele inheritance independent (true meiotic siblings) Aibling relationships transitive (true parent-child-like trios half-sibling trios) Alleles sibling cluster drawn two parental alleles (true half siblings) experience, half sibling misspecification leads misclassification relapses reinfections; see Understand half-sibling misspecification. descriptive study explore extent half-sibling misspecification recommended (example provided upcoming manuscript).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"observation-errors-and-de-novo-mutations","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Observation errors and de novo mutations","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"model undetected alleles, genotyping errors, de novo mutations. Recrudescent parasites modelled perfect clones Pv3Rs. , posterior probability recrudescence rendered zero errors mutations. becomes likely data markers. Sensitivity analyses explore impact errors mutations recurrence state probabilities merited.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"interpreting-probable-reinfection-and-recrudescence","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Interpreting probable reinfection and recrudescence","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"data sufficiently informative distinguish recrudescence relapse (reinfection relapse), posterior probabilities recrudescence relapse (reinfection relapse) heavily influenced model assumption relationship graphs; see Understand graph-prior ramifications. development biologically-principled generative model parasite relationships merited.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"computational-limits","dir":"","previous_headings":"Please be aware of the following points!","what":"Computational limits:","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Pv3Rs scales hundreds markers whole-genome sequence (WGS) data. recommend running compute_posterior() data whose total genotype count (sum per-episode multiplicities infection) exceeds eight. total genotype counts exceeds eight multiple recurrences, might possible compute posterior probabilities analysing episodes pairwise (approach used [2] ’re working currently improved version). per-marker allele limit compute_posterior() untested. high marker cardinalities lead small allele frequencies thus underflow problems.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"population-level-allele-frequencies","dir":"","previous_headings":"Please be aware of the following points!","what":"Population-level allele frequencies:","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"addition P. vivax allelic data two episodes, compute_posterior() requires input population-level allele frequencies. minimise bias due within-host selection recrudescent parasites, recommend using enrolment episodes estimate population-level allele frequencies, ideally enrolment episodes study participants selected random, study participants experience recurrence. said, recurrences either reinfections relapses, draws mosquito population (albeit delayed draw case relapse), assuming systematic within-patient selection (might occur infections encounter lingering drug pressure), estimates based episodes unbiased precise based enrolment episodes .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"read-count-data","dir":"","previous_headings":"Please be aware of the following points!","what":"Read-count data:","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Unfortunately, Pv3Rs model exploit data read counts present. However, read-count data used compute population-level allele frequencies, assuming biased experimental artefacts.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"","code":"#=============================================================================== # First try installing Pv3Rs from CRAN (available soon if not already): #=============================================================================== install.packages(\"Pv3Rs\")  #=============================================================================== # If Pv3Rs is not available on CRAN: #=============================================================================== # Install or update devtools from CRAN install.packages(\"devtools\")  # Install Pv3Rs from GitHub  # We recommend doing this in RStudio: RStudio installs pandoc, required for # vignette building. If not, you might need to install pandoc and check its # path; otherwise set build_vignettes = FALSE devtools::install_github(\"aimeertaylor/Pv3Rs\", build_vignettes = TRUE)  #=============================================================================== # Getting started after installation: #=============================================================================== # Load and attach Pv3Rs library(Pv3Rs)  # List links to all available documentation help(package = \"Pv3Rs\")  # List links to vignettes vignette(package = \"Pv3Rs\")  # View function documentation including examples, e.g.,  ?compute_posterior"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/Pv3Rs-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Pv3Rs: Estimate the Cause of Recurrent Vivax Malaria using Genetic Data — Pv3Rs-package","title":"Pv3Rs: Estimate the Cause of Recurrent Vivax Malaria using Genetic Data — Pv3Rs-package","text":"Plot malaria parasite genetic data two episodes. Compute per-person posterior probabilities Plasmodium vivax (Pv) recurrence recrudescence, relapse, reinfection (3Rs) using per-person P. vivax genetic data two episodes statistical model described Taylor, Foo White (2022) doi:10.1101/2022.11.23.22282669 . Plot per-recurrence posterior probabilities.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/Pv3Rs-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pv3Rs: Estimate the Cause of Recurrent Vivax Malaria using Genetic Data — Pv3Rs-package","text":"Maintainer: Aimee Taylor aimee.taylor@pasteur.fr (ORCID) Authors: Yong See Foo (ORCID) contributors: Mans Magnusson [contributor] Institut Pasteur [copyright holder] European Union, Project 101110393 [funder]","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"Converts RG encoded list igraph object, requires memory allocation can plotted using plot_RG.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"","code":"RG_to_igraph(RG, MOIs)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"RG List encoding RG; see Value enumerate_RGs igraph = FALSE. MOIs Vector per-episode multiplicities infection (MOIs), .e., numbers per-episode genotypes / vertices; adds graph attribute used plot_RG group genotypes / vertices episode.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"weighted graph whose edge weights 1 0.5 encode clonal sibling relationships, respectively.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"","code":"MOIs <- c(3,2) set.seed(6) RG_as_list <- sample_RG(MOIs, igraph = FALSE) RG_as_igraph <- RG_to_igraph(RG_as_list,  MOIs)  # RG encoded as a list requires less memory allocation utils::object.size(RG_as_list) #> 2512 bytes utils::object.size(RG_as_igraph) #> 4568 bytes  # RG encoded as an igraph object can be plotted using plot_RG() and # manipulated using igraph functions plot_RG(RG_as_igraph, margin = rep(0,4), vertex.label = NA)   # Edge weights 1 and 0.5 encode clonal and sibling relationships igraph::E(RG_as_igraph)$weight #> [1] 0.5 0.5 1.0  # Vertex attribute group encodes episode membership igraph::V(RG_as_igraph)$group #> [1] 1 1 1 2 2"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"Computes per-person posterior probabilities P. vivax recurrence states — recrudescence, relapse, reinfection — using per-person genetic data two episodes. usage, see Examples Demonstrate Pv3Rs usage . complete understanding compute_posterior output, see Understand posterior probabilities. Note: progress bar may increment non-uniformly (see Details); may appear stuck computations ongoing.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"","code":"compute_posterior(   y,   fs,   prior = NULL,   MOIs = NULL,   return.RG = FALSE,   return.logp = FALSE,   progress.bar = TRUE )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"y List lists encoding allelic data. outer list contains episodes chronological order. inner list contains named markers per episode. Marker names must consistent across episodes. NA indicates missing marker data; otherwise, specify per-marker vector distinct alleles detected (presently, compute_posterior() support data proportional abundance detected alleles). Repeat alleles NA entries within allelic vectors ignored. Allele names arbitrary, allowing different data types, must correspond frequency names. fs List per-marker allele frequency vectors, names matching marker names y. Per-marker alleles frequencies mut contain one frequency per named allele, names matching alleles y. Per-marker frequencies must sum one. prior Matrix prior probabilities recurrence states per episode, rows episodes chronological order, columns named \"C\", \"L\", \"\" recrudescence, relapse reinfection, respectively. Row names ignored. NULL (default), per-episode recurrence states assumed equally likely priori. MOIs Vector per-episode multiplicities infection (MOIs); Pv3Rs model assumes genotyping errors, MOIs must greater equal parsimonious MOI estimates compatible data; see determine_MOIs(y). estimates used MOIs = NULL (default). return.RG Logical; returns relationship graphs (default FALSE). Automatically set TRUE return.logp = TRUE. return.logp Logical; returns log-likelihood relationship graph (default FALSE). Setting TRUE disables permutation symmetry optimisation thus increases runtime, especially MOIs large. affect output posterior probabilities; example permutation symmetry, see Exploration relationship graphs Demonstrate Pv3Rs usage . progress.bar Logical; show progress bars (default TRUE). Note progress bar may update non-uniformly.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"List containing: marg Matrix marginal posterior probabilities recurrence, rows recurrences columns \"C\" (recrudescence), \"L\" (relapse), \"\" (reinfection). marginal probability sums subset joint probabilities. example, marginal probability \"C\" first two recurrences sums joint probabilities \"CC\", \"CL\", \"CI\". joint Vector joint posterior probabilities recurrence state sequence; within sequence \"C\", \"L\", \"\" used . RGs List lists encoding relationship graphs; returned return.RG = TRUE (default FALSE), log-likelihoods return.logp = TRUE (default FALSE). relationship graph encoded list can converted igraph object using RG_to_igraph thus plotted using plot_RG. details relationship graphs, see enumerate_RGs.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"compute_posterior() computes posterior probabilities proportional likelihood multiplied prior. likelihood sums : ways phase allelic data onto haploid genotypes graphs relationships haploid genotypes ways partition alleles clusters identity--descent enumerate possible relationship graphs haploid genotypes, pairs genotypes can either clones, siblings, strangers. likelihood sequence recurrence states can determined likelihood relationship graphs compatible said sequence. details enumeration relationship graphs can found enumerate_RGs. relationship graph, model sums possible identity--descent partitions. graphs compatible partitions others, log p(Y|RG) progress bar may advance non-uniformly. recommend running `compute_posterior() total genotype count (sum MOIs) exceeds eight many relationship graphs. Notable model assumptions limitations: siblings regular siblings Recrudescent parasites derive immediately preceding episode Recrudescence, relapse reinfection mutually exclusive Undetected alleles, genotyping errors, de novo mutations modelled Population structure various complexities confound molecular correction modelled","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"","code":"# Numerically named alleles y <- list(enrol = list(m1 = c('3','2'), m2 = c('1','2')),           recur1 = list(m1 = c('1','4'), m2 = c('1')),           recur2 = list(m1 = c('1'), m2 = NA)) fs <- list(m1 = c('1' = 0.78, '2' = 0.14, '3' = 0.07, '4' = 0.01),            m2 = c('1' = 0.27, '2' = 0.73)) compute_posterior(y, fs, progress.bar = FALSE) #> Number of valid relationship graphs (RGs) is 250 #> Computing log p(Y|RG) for 250 RGs #> Finding log-likelihood of each vector of recurrence states #>  #> $marg #>                C         L         I #> recur1 0.0000000 0.1949556 0.8050444 #> recur2 0.2938829 0.2476598 0.4584573 #>  #> $joint #>         CC         LC         IC         CL         LL         IL         CI  #> 0.00000000 0.05539481 0.23848807 0.00000000 0.05314490 0.19451493 0.00000000  #>         LI         II  #> 0.08641590 0.37204139  #>    # Arbitrarily named alleles, plotting per-recurrence posteriors y <- list(enrolment = list(marker1 = c(\"Tinky Winky\", \"Dipsy\"),                           marker2 = c(\"Tinky Winky\", \"Laa-Laa\", \"Po\")),           recurrence = list(marker1 = \"Tinky Winky\",                           marker2 = \"Laa-Laa\")) fs <- list(marker1 = c(\"Tinky Winky\" = 0.4, \"Dipsy\" = 0.6),            marker2 = c(\"Tinky Winky\" = 0.1, \"Laa-Laa\" = 0.1, \"Po\" = 0.8)) plot_simplex(p.coords = compute_posterior(y, fs, progress.bar = FALSE)$marg) #> Number of valid relationship graphs (RGs) is 30 #> Computing log p(Y|RG) for 30 RGs #> Finding log-likelihood of each vector of recurrence states #>     # Episode names are cosmetic: \"r1_prior\" is returned for \"r2\" y <- list(enrol = list(m1 = NA), r2 = list(m1 = NA), r1 = list(m1 = NA)) prior <- matrix(c(0.6,0.7,0.2,0.3,0.2,0), ncol = 3,                 dimnames = list(c(\"r1_prior\", \"r2_prior\"), c(\"C\", \"L\", \"I\"))) suppressMessages(compute_posterior(y, fs = list(m1 = c(a = 1)), prior))$marg #> Warning: Data and prior episode names disagree #> Warning: Marker m1 has data on fewer than two episodes #> Warning: Episodes enrol & r2 & r1 have no data #>      C   L   I #> r2 0.6 0.2 0.2 #> r1 0.7 0.3 0.0 prior #>            C   L   I #> r1_prior 0.6 0.2 0.2 #> r2_prior 0.7 0.3 0.0   # Prior is returned when all data are missing y_missing <- list(enrol = list(m1 = NA), recur = list(m1 = NA)) suppressMessages(compute_posterior(y_missing, fs = list(m1 = c(\"A\" = 1)))) #> Warning: Marker m1 has data on fewer than two episodes #> Warning: Episodes enrol & recur have no data #> $marg #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333 #>  #> $joint #>         C         L         I  #> 0.3333333 0.3333333 0.3333333  #>    # Return of the prior re-weighted to the exclusion of recrudescence: suppressMessages(compute_posterior(y_missing, fs = list(m1 = c(\"A\" = 1)),                  MOIs = c(1,2))) #> Warning: Marker m1 has data on fewer than two episodes #> Warning: Episodes enrol & recur have no data #> $marg #>       C   L   I #> recur 0 0.5 0.5 #>  #> $joint #>   C   L   I  #> 0.0 0.5 0.5  #>  # (Recrudescing parasites are clones of previous blood-stage parasites. The # Pv3R model assumes no within-host de-novo mutations and perfect allele # detection. As such, recrudescence is incompatible with an MOI increase on # the preceding infection.)   # Beware provision of unpaired data: the prior is not necessarily returned; # for more details, see link above to \"Understand posterior estimates\" y <- list(list(m1 = c('1', '2')), list(m1 = NA)) fs <- list(m1 = c('1' = 0.5, '2' = 0.5)) suppressMessages(compute_posterior(y, fs))$marg #> Warning: Marker m1 has data on fewer than two episodes #> Warning:  #>              C         L         I #> [1,] 0.3292683 0.3414634 0.3292683"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine multiplicities of infection (MOIs) — determine_MOIs","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"Returns MOI estimate episode based allelic diversity across markers.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"","code":"determine_MOIs(y, return.names = FALSE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"y List lists encoding allelic data; see compute_posterior details. outer list contains episodes chronological order. inner list contains named markers per episode. marker, one must specify allelic vector: set distinct alleles detected marker; NA marker data missing. return.names Logical; TRUE y named episodes, episode names returned.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"Numeric vector containing one MOI estimate per episode, estimate representing maximum number distinct alleles observed marker per episode.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"true MOI number genetically distinct groups clonal parasites within infection. Give take de novo mutations, parasites within clonal group share DNA sequence, call genotype. , MOIs distinct parasite genotype counts. Pv3Rs model assumption genotyping errors, true MOI episode greater equal maximum distinct allele count marker data episode. words, assumption genotyping errors, maximum distinct allelic counts parsimonious MOI estimates compatible data. default, MOI estimates used compute_posterior.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"","code":"y <- list(enrol = list(m1 = c(\"A\", \"B\"), m2 = c(\"A\"), m3 = c(\"C\")),           recur = list(m1 = c(\"B\"), m2 = c(\"B\", \"C\"), m3 = c(\"A\", \"B\", \"C\"))) determine_MOIs(y) # returns c(2, 3) #> [1] 2 3"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":null,"dir":"Reference","previous_headings":"","what":"Enumerate relationship graphs (RGs) — enumerate_RGs","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"RG graph per-person parasite genotypes (vertex), edges clone sibling genotypes. Valid RGs satisfy: Subgraphs induced clone edges cluster graphs. Subgraphs induced clone plus sibling edges cluster graphs. Clone edges link genotypes different episodes.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"","code":"enumerate_RGs(MOIs, igraph = TRUE, progress.bar = TRUE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"MOIs Vector per-episode multiplicities infection (MOIs), .e., numbers per-episode genotypes / vertices. igraph Logical; returns RGs igraph objects (default TRUE). progress.bar Logical; show progress bar (default TRUE).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"list RGs. igraph = FALSE, RG list length four : clone List vectors encoding genotypes per clonal cell. clone.vec Numeric vector clonal cell membership genotype. sib List vectors encoding clonal cells per sibling cell. sib.vec Numeric vector sibling cell membership clonal cell. igraph = TRUE (default), RG encoded igraph object (see RG_to_igraph).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"RGs generated enumerating nested set partitions specific constraints; see Understand graph partition enumeration. nested set parition RG. Clone edges induce cluster graph, equivalent partition genotypes, intra-episode clones allowed. Sibling edges refine clone partition, constraints (intra-episode siblings allowed). nested set partition encoded list. partition represented list vectors (either clone sib) membership vector (either clone.vec sib.vec). default, RG encoded list converted igraph object.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"","code":"graphs <- enumerate_RGs(c(2, 1, 2), progress.bar = FALSE) # nine graphs #> Number of valid relationship graphs (RGs) is 250"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":null,"dir":"Reference","previous_headings":"","what":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"posterior mean multinomial-Dirichlet model uniform prior fit data allele prevalence initial episodes ys_VHX_BPD. model fit allele prevalence (observed) allele frequency ( requires integrating-unknown multiplicities infection) liable underestimate frequencies common alleles overestimate rare detected alleles.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"","code":"fs_VHX_BPD"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"list nine markers; marker named vector allele frequencies sum one.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"https://zenodo.org/records/3368828 https://github.com/aimeertaylor/Pv3Rs/blob/main/data-raw/fs_VHX_BPD.R","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a relationship graph (RG) — plot_RG","title":"Plot a relationship graph (RG) — plot_RG","text":"function wrapper around plot.igraph, written group parasite genotypes episode spatially using vertex colour (specifically, parasite genotypes within episodes vertically distributed horizontal jitter layout..group = TRUE (default), equicolored), ensure clone sibling edges plotted using different line types.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a relationship graph (RG) — plot_RG","text":"","code":"plot_RG(   RG,   layout.by.group = TRUE,   vertex.palette = \"Set2\",   edge.lty = c(sibling = \"dashed\", clone = \"solid\"),   edge.col = c(sibling = \"black\", clone = \"black\"),   edge.width = 1.5,   ... )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a relationship graph (RG) — plot_RG","text":"RG igraph object encoding RG; see RG_to_igraph. layout..group Logical; TRUE (default) overrides default layout plot.igraph vertices represent parasite genotypes different episodes distributed horizontally vertices represent genotypes within episodes distributed vertically. vertex.palette character string specifying RColorBrewer palette. Overrides default palette plot.igraph. edge.lty Named vector edge line types corresponding different relationships. edge.col Named vector edge colours corresponding different relationships. edge.width Overrides default edge.width plot.igraph. ... Additional arguments pass plot.igraph, e.g., edge.curved.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a relationship graph (RG) — plot_RG","text":"None","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"provenance","dir":"Reference","previous_headings":"","what":"Provenance","title":"Plot a relationship graph (RG) — plot_RG","text":"function adapted plot_Vivax_model https://github.com/jwatowatson/RecurrentVivax/blob/master/Genetic_Model/iGraph_functions.R.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a relationship graph (RG) — plot_RG","text":"","code":"RGs <- enumerate_RGs(c(2, 1, 1), progress.bar = FALSE) #> Number of valid relationship graphs (RGs) is 48 cpar <- par(no.readonly = TRUE) # record current par before changing par(mfrow = c(3, 4), mar = c(0.1, 0.1, 0.1, 0.1)) for (i in 12:23) {   plot_RG(RGs[[i]],   edge.col = c(sibling = \"gray\", clone = \"black\"),   edge.lty = c(sibling = \"dotted\", clone = \"solid\"),   edge.curved = 0.1)   box() }  par(cpar) # reset par"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots the data — plot_data","title":"Plots the data — plot_data","text":"Plots allelic data grid coloured rectangles.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots the data — plot_data","text":"","code":"plot_data(   ys,   fs = NULL,   person.vert = FALSE,   mar = c(1.5, 3.5, 1.5, 1),   gridlines = TRUE,   palette = RColorBrewer::brewer.pal(12, \"Paired\"),   marker.annotate = TRUE,   legend.lab = \"Allele frequencies\",   legend.line = 0.2,   legend.ylim = c(0.05, 0.2),   cex.maj = 0.7,   cex.min = 0.5,   cex.text = 0.5,   x.line = 0.2,   y.line = 2.5 )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots the data — plot_data","text":"ys Nested list per-person, per-episode, per-marker allelic data; see Examples compute_posterior() expected per-person structure. fs per-marker list numeric vectors allele frequencies. NULL (default), alleles present ys shown legend, per-marker alleles represented equally. colour scheme adaptive, allele may different colours given different ys. fs specified, alleles fs feature legend areas proportional allele frequencies, common alleles occupy larger areas rarer alleles. Specify fs fix allele colour scheme across plots different ys. person.vert Logical. TRUE (default), person IDs printed vertically; otherwise, printed horizontally. mar Vector numbers lines margin main plot; see mar entry par. gridlines Logical. true (default), white grid lines separating people markers drawn. palette Colour palette alleles, see Value section brewer.pal. Generally, colours interpolated: marker d possible alleles, colours used 1/(d+1), ..., d/(d+1) quantiles palette ensure markers different allele counts use different colours. marker.annotate Logical. true (default), names alleles printed top colours legend. legend.lab Label axis legend. Defaults \"Allele frequencies\". Set NA omit label; , consider adjusting legend.ylim use plotting space. legend.line Distance (character heights) colour bar legend label (defaults 1.5). legend.ylim Vector specifying y-coordinate limits legend device coordinates (0 1). Defaults c(0.05, 0.2). cex.maj Numeric; font scaling major axis labels. cex.min Numeric; font scaling minor axis labels. cex.text Numeric; font scaling allele labels. x.line Distance top x-axis x-axis label, defaults 0.2. y.line Distance left y-axis y-axis label, defaults 2.5.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots the data — plot_data","text":"None","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plots the data — plot_data","text":"function plots alleles (colours), observed different episodes (columns), different markers (rows), episodes grouped person. Per-person episodes plotted left right chronological order. multiple alleles detected marker within episode, corresponding grid element subdivided vertically different colours. default, markers ordered lexicographically. fs provided, markers ordered match order within fs. legend depicts alleles marker vertical order main plot. default colour scheme adaptive, designed visually differentiate alleles clearly possible maximizing hue contrast within qualitative palette. Interpolation used make different colour palettes markers different numbers possible alleles. names alleles printed top colours marker.annotate set TRUE.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots the data — plot_data","text":"","code":"# Plot example Plasmodium vivax data set mar <- c(2, 3.5, 1.5, 1) # extra vertical margin for vertical person labels plot_data(ys = ys_VHX_BPD, person.vert = TRUE, mar = mar, legend.lab = NA)  plot_data(ys = ys_VHX_BPD, person.vert = TRUE, mar = mar, legend.lab = NA,           fs = fs_VHX_BPD)  plot_data(ys = ys_VHX_BPD, person.vert = TRUE, mar = mar, legend.lab = NA,           fs = fs_VHX_BPD, marker.annotate = FALSE)   # Demonstrating the adaptive nature of the colour scheme: ys <- ys_VHX_BPD[\"VHX_52\"] # A single person plot_data(ys, fs = fs_VHX_BPD, marker.annotate = FALSE) # Colours match above  plot_data(ys) # Colours and the legend adapt to alleles detected in VHX_52"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots a 2D simplex — plot_simplex","title":"Plots a 2D simplex — plot_simplex","text":"Plots 2D simplex (triangle unit sides centered origin) onto per-recurrence posterior probabilities recrudescence, relapse, reinfection (probability triplet summing one) can projected; see project2D() Examples .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots a 2D simplex — plot_simplex","text":"","code":"plot_simplex(   v.labels = c(\"Recrudescence\", \"Relapse\", \"Reinfection\"),   v.cutoff = 0.5,   v.colours = c(\"yellow\", \"purple\", \"red\"),   plot.tri = TRUE,   p.coords = NULL,   p.labels = rownames(p.coords),   p.labels.pos = 3,   p.labels.cex = 1,   ... )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots a 2D simplex — plot_simplex","text":"v.labels Vertex labels anticlockwise top (default: \"Recrudescence\", \"Relapse\", \"Reinfection\"). NULL, vertices labelled. v.cutoff Number 0.5 1 separates lower vs higher probability regions. Use caution recrudescence reinfection classification; see Understand posterior probabilities. v.colours Vertex colours anticlockwise top. plot.tri Logical; draws triangular boundary TRUE (default). p.coords Matrix 3D simplex coordinates (e.g., per-recurrence probabilities recrudescence, relapse reinfection), one vector 3D coordinates per row, row projected onto 2D coordinates using project2D() plotted single simplex point using graphics::points(). user provides vector encoding probability triplet summing one, converted matrix one row. p.labels Labels points p.coords (default row names p.coords) labels NA. p.labels.pos Position p.labels: 1 = , 2 = left, 3 = (default) 4 = right. Can single value vector. p.labels.cex Size expansion p.labels passed text. ... Additional parameters passed graphics::points().","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots a 2D simplex — plot_simplex","text":"None","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots a 2D simplex — plot_simplex","text":"","code":"# Plot 2D simplex plot_simplex(p.coords = diag(3),              p.labels = c(\"(1,0,0)\", \"(0,1,0)\", \"(0,0,1)\"),              p.labels.pos = c(1,3,3))   # ============================================================================== # Given data on an enrollment episode and a recurrence, # compute the posterior probabilities of the 3Rs and plot the deviation of the # posterior from the prior # ==============================================================================  # Some data: y <- list(list(m1 = c('a', 'b'), m2 = c('c', 'd')), # Enrollment episode           list(m1 = c('a'), m2 = c('c'))) # Recurrent episode  # Some allele frequencies: fs <- list(m1 = setNames(c(0.4, 0.6), c('a', 'b')),            m2 = setNames(c(0.2, 0.8), c('c', 'd')))  # A vector of prior probabilities: prior <- array(c(0.2, 0.3, 0.5), dim = c(1,3),                dimnames = list(NULL, c(\"C\", \"L\", \"I\")))  # Compute posterior probabilities post <- compute_posterior(y, fs, prior, progress.bar = FALSE) #> Number of valid relationship graphs (RGs) is 9 #> Computing log p(Y|RG) for 9 RGs #> Finding log-likelihood of each vector of recurrence states #>   # Plot simplex with the prior and posterior plot_simplex(p.coords = rbind(prior, post$marg),              p.labels = c(\"Prior\", \"Posterior\"),              pch = 20)  # Add the deviation between the prior and posterior: requires obtaining 2D # coordinates manually xy_prior <- project2D(as.vector(prior)) xy_post <- project2D(as.vector(post$marg)) arrows(x0 = xy_prior[\"x\"], x1 = xy_post[\"x\"],        y0 = xy_prior[\"y\"], y1 = xy_post[\"y\"], length = 0.1)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":null,"dir":"Reference","previous_headings":"","what":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"Project three probabilities sum one (e.g., per-recurrence probabilities recrudescence, relapse reinfection) onto coordinates 2D simplex centred origin (.e., triangle centred (0,0) unit-length sides).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"","code":"project2D(v)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"v numeric vector three numbers zero one sum one.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"numeric vector two coordinates can used plot probability vector v origin-centred 2D simplex.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"top, left, right vertices 2D simplex correspond first, second third entries v, respectively. probability proportional distance point simplex side opposite corresponding probability; see Examples plot_simplex() details.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"","code":"probabilities_of_v1_v2_v3 <- c(0.75,0.20,0.05) coordinates <- project2D(v = probabilities_of_v1_v2_v3)  # Plot probability vector on 2D simplex plot_simplex(v.labels = c(\"v1\", \"v2\", \"v3\")) points(x = coordinates[1], y = coordinates[2], pch = 20)  # Plot the distances that represent probabilities # get vertices, get points on edges by orthogonal projection, plot arrows v <- apply(matrix(c(1,0,0,0,1,0,0,0,1), nrow = 3), 1, project2D) p3 <- v[,1] + sum((coordinates - v[,1]) * (v[,2] - v[,1])) * (v[,2] - v[,1]) p1 <- v[,2] + sum((coordinates - v[,2]) * (v[,3] - v[,2])) * (v[,3] - v[,2]) p2 <- v[,3] + sum((coordinates - v[,3]) * (v[,1] - v[,3])) * (v[,1] - v[,3]) arrows(x0 = coordinates[1], y0 = coordinates[2], x1 = p1[1], y1 = p1[2], length = 0.1) arrows(x0 = coordinates[1], y0 = coordinates[2], x1 = p2[1], y1 = p2[2], length = 0.1) arrows(x0 = coordinates[1], y0 = coordinates[2], x1 = p3[1], y1 = p3[2], length = 0.1)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample a relationship graph (RG) — sample_RG","title":"Sample a relationship graph (RG) — sample_RG","text":"Uses techniques enumerate_RGs sample single RG uniformly. clonal partitions generated, weighted number consistent sibling partitions. clonal partition sampled proportional weight, consistent sibling partition drawn uniformly. resulting nested partition represents RG; see enumerate_RGs details.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample a relationship graph (RG) — sample_RG","text":"","code":"sample_RG(MOIs, igraph = TRUE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample a relationship graph (RG) — sample_RG","text":"MOIs Vector per-episode multiplicities infection (MOIs), .e., numbers per-episode genotypes / vertices. igraph Logical; TRUE (default), returns RG igraph object.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample a relationship graph (RG) — sample_RG","text":"RG encoded either igraph object (default), list; see enumerate_RGs details.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample a relationship graph (RG) — sample_RG","text":"","code":"set.seed(1) RG <- sample_RG(c(3, 2)) plot_RG(RG, vertex.label = NA)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Plasmodium vivax data — ys_VHX_BPD","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"Previously-published microsatellite data P. vivax parasites extracted study participants enrolled Best Primaquine Dose (BPD) Vivax History (VHX) trials; see Taylor & Watson et al. 2019 (doi:10.1038/s41467-019-13412-x ) details genetic data; details VHX BPD trials, see Chu et al. 2018a (doi:10.1093/cid/ciy319 ) Chu et al. 2018b (doi:10.1093/cid/ciy735 ).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"","code":"ys_VHX_BPD"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"list 217 study participants; study participant, list one episodes; episode, list three microsatellite markers; marker, vector observed alleles (repeat lengths). example: BPD_103 Study participant identifier: study participant 103 BPD trial BPD_103_1 Episode identifier: episode one study participant 103 BPD trial PV.3.27 Marker identifier: P. vivax 3.27 18 Allele identifier: 18 repeat lengths","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"https://zenodo.org/records/3368828 https://github.com/aimeertaylor/Pv3Rs/blob/main/data-raw/ys_VHX_BPD.R","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/news/index.html","id":"pv3rs-development-version","dir":"Changelog","previous_headings":"","what":"Pv3Rs (development version)","title":"Pv3Rs (development version)","text":"Initial CRAN submission.","code":""}]
