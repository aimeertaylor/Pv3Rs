[{"path":"https://aimeertaylor.github.io/Pv3Rs/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 l’INSTITUT PASTEUR Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"basic-workflow","dir":"Articles","previous_headings":"","what":"Basic workflow","title":"Demonstrate Pv3Rs usage","text":"begin synthetic example three episodes (episode names optional) three markers (marker names obligatory) whose alleles known frequencies, fs.","code":"y <- list(\"Enrolment\" = list(m1 = c('b','c','d'),                                m2 = c('a','b'),                               m3 = c('b','c','d')),           \"Recurrence 1\" = list(m1 = c('b','d'),                                  m2 = c('a'),                                  m3 = c('a','b')),           \"Recurrence 2\" = list(m1 = c('d'),                                  m2 = c('a'),                                  m3 = c('a')))  fs <- list(m1 = c(a = 0.27, b = 0.35, c = 0.18, d = 0.20),            m2 = c(a = 0.78, b = 0.14, c = 0.07, d = 0.01),            m3 = c(a = 0.21, b = 0.45, c = 0.26, d = 0.08))"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"plot-data","dir":"Articles","previous_headings":"Basic workflow","what":"1) Plot data","title":"Demonstrate Pv3Rs usage","text":"plot data using plot_data().  marker, different colours represent different alleles. legend main grid shows per-marker allele frequencies via colour proportions, one row per marker, ordered main grid; e.g., d m2 rare. parsimonious MOI estimates compatible data, 3, 2, 1, computed using determine_MOIs(). total genotype count (sum MOIs) 6. Aside synthetic example, markers quart-allelic, imposing low upper bounds MOI estimates based maximum per-marker allele counts. diverse markers recommended MOI estimation recurrence state inference.","code":"plot_data(ys = list(\"Participant data\" = y), fs = fs)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"compute-recurrence-state-posterior-probabilities","dir":"Articles","previous_headings":"Basic workflow","what":"2) Compute recurrence state posterior probabilities","title":"Demonstrate Pv3Rs usage","text":"bulk computational time lies computing log-likelihoods graphs relationships genotypes. number graphs depends MOIs. default, compute_posterior uses MOI estimates generated determine_MOIs. Aside recommend running compute_posterior() data whose total genotype count (sum MOIs) exceeds eight. said, encoded hard limit. experience, possible, long, generate posterior probabilities using data total genotype count 10; 10, calls compute_posterior() liable cause memory-use problems fail. call compute_posterior() specify prior, default three recurrence states assumed equally likely per recurrence. Posterior probabilities recurrent state sequences (C recrudescence, L relapse, reinfection) stored post$joint. , find likely sequence recurrence states IC posterior probability 0.4568: Per-recurrence posterior probabilities recrudescence C, relapse L, reinfection stored post$marg. refer per-recurrence probabilities marg (shorthand marginal) computed simply summing state sequence probabilities. example, probability L Recurrence 1 sum probabilities LC, LL LI:","code":"post <- compute_posterior(y, fs) #> Number of valid relationship graphs (RGs) is 1315 #> =============================================================================| #> Computing log p(Y|RG) for 1315 RGs #> =============================================================================| #> Finding log-likelihood of each vector of recurrence states #> =============================================================================| sort(post$joint, decreasing = T) #>         IC         LC         IL         LL         II         LI         CC  #> 0.45682305 0.21338194 0.15385932 0.08501504 0.05986209 0.03105856 0.00000000  #>         CL         CI  #> 0.00000000 0.00000000 post$marg #>                     C         L          I #> Recurrence 1 0.000000 0.3294555 0.67054446 #> Recurrence 2 0.670205 0.2388744 0.09092065 post$joint[\"LC\"] + post$joint[\"LL\"] + post$joint[\"LI\"] #>        LC  #> 0.3294555"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"plot-per-recurrence-probabilities","dir":"Articles","previous_headings":"Basic workflow","what":"3) Plot per-recurrence probabilities","title":"Demonstrate Pv3Rs usage","text":"Per-recurrence posterior probabilities plotted simplex using plot_simplex().  point yellow region likely recrudescence posterior probability greater 0.5 (falls bright yellow region); point red region likely reinfection posterior probability greater 0.5 (falls bright red region).","code":"par(mar = rep(0.1,4)) p.coords <- rbind(post$marg, Prior = rep(1/3, 3)) plot_simplex(p.coords = p.coords, pch = 20)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/demonstrate-usage.html","id":"exploration-of-relationship-graphs","dir":"Articles","previous_headings":"","what":"Exploration of relationship graphs","title":"Demonstrate Pv3Rs usage","text":"explore relationship graphs (RGs) log-likelihoods, set return.RG return.logp TRUE. recover posterior . compute time longer: compute posterior, summations per-marker allelic assignments equivalent within-episode genotype permutations redundant. , default, compute_posterior() sum , conserving memory compute time. exploitation permutation symmetry requires scheme choose single representative among permutations otherwise equivalent. compute meaningful graph likelihood values (values depend representative-choosing scheme), permutations summed return.logp = TRUE, increasing compute time, especially MOIs large. Also, user-specified MOIs exceed determine_MOIs(), permutations summed representative-choosing scheme complicated. log-likelihood relationship graph returned. plot relationship graph(s) largest likelihood. example, two graphs maximum likelihood; isomorphic within-episode genotype permutations.  Using log likelihoods, can also find equivalence class data probable relationship graphs class summed .  Important considerations maximum-likelihood graph(s) might equivalence class data probable relationship graphs class summed (true example). maximum-likelihood graph(s) might incompatible maximum-posterior state sequence, (true example; recall -likely sequence IC). graphs maximum-likelihood equivalence class might incompatible maximum-posterior state sequence (true example; class largest likelihood contains graphs sibling edges incompatible IC).","code":"post <- compute_posterior(y, fs, return.RG = TRUE, return.logp = TRUE) #> Number of valid relationship graphs (RGs) is 1315 #> =============================================================================| #> Computing log p(Y|RG) for 1315 RGs #> =============================================================================| #> Finding log-likelihood of each vector of recurrence states #> =============================================================================| sort(post$joint, decreasing = T) #>         IC         LC         IL         LL         II         LI         CC  #> 0.45682305 0.21338194 0.15385932 0.08501504 0.05986209 0.03105856 0.00000000  #>         CL         CI  #> 0.00000000 0.00000000 # Extract all log likelihoods llikes <- sapply(post$RGs, function(RG) RG$logp)  # Get maximum log likelihood mllikes <- max(llikes)  # Extract the relationship graphs (RGs) with the maximum log likelihood RGs <- post$RGs[which(abs(llikes - mllikes) < .Machine$double.eps^0.5)]  # Plot RGs with maximum log likelihoods par(mar = rep(0.1,4), mfrow = c(1,2)) for(i in 1:length(RGs)) {   plot_RG(RG_to_igraph(RGs[[i]], determine_MOIs(y)), vertex.size = 20)   box() }  # Add a legend legend(\"bottomright\", pch = 21,         pt.bg =  RColorBrewer::brewer.pal(n = 8, \"Set2\") [1:length(y)],         bty = \"n\", legend = names(y), title = \"Episode\") # In the following code, we place two graphs in the same equivalence class if # they share the same likelihood. This is not ideal (two graphs that are not # isomorphic up to permutation could share the same likelihood), but it works # here: the plot shows only isomorphic graphs within the equivalence class.  sorted_llikes <- sort(llikes, decreasing = T) # Sort log likelihoods adj_equal <- abs(diff(sorted_llikes, lag = 1)) < .Machine$double.eps^0.5 # Find matches decr_idxs <- which(adj_equal == FALSE) # Change points: 2, 8, 14, 20, 32, ... class_sizes <- c(decr_idxs[1], diff(decr_idxs)) # Number of graphs per class  # log likelihood of representative from each 'equivalence class' (EC) llikes_unique <- sorted_llikes[decr_idxs]  # EC likelihood class_ps <- exp(llikes_unique)*class_sizes max_class_p <- which(class_ps == max(class_ps)) # ML EC index  max_idx <- decr_idxs[max_class_p] # Index of last graph in ML EC max_size <- class_sizes[max_class_p] # Number of graphs in ML EC  # Plot all graphs within the ML EC  par(mar = rep(0.1,4), mfrow = c(3,4)) RG_order <- order(llikes, decreasing = T) # order RGs by logl for(i in (max_idx-max_size+1):max_idx) { # EC consists of the RGs with logl rank 21-32   RG <- post$RGs[[RG_order[i]]]   RG_igraph <- RG_to_igraph(RG, determine_MOIs(y))   plot_RG(RG_igraph, vertex.size = 25, vertex.label = NA)   box() }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/intra-episode-siblings.html","id":"example-of-a-group-of-four-intra-episode-siblings-collapsing-to-two","dir":"Articles","previous_headings":"","what":"Example of a group of four intra-episode siblings collapsing to two","title":"Explore treatment of intra-episode siblings","text":"demonstrating intra-episode sibling groups collapse pairs, write function simulate data 200 markers user-specified allelic richness (marker cardinality) enrolment episode comprising stranger plus group four siblings, two one oocyst, two another, drawing two unrelated parental genotypes, recurrence one sibling. Technically, enrolment episode contains five genetically distinct genotypes thus MOI five. However, MOI estimates based maximum per-marker allele counts three one markers polyallelic: two one markers biallelic: Suppose estimate MOIs 3 1 biallelic data using external software exploits heteroallelic marker counts, input external estimates compute_posterior(). Providing data simulated large number markers (200 ), recover almost exactly posterior probabilities using polyallelic data without user-specified MOIs biallelic data user-specified MOIs three one However, following graphs, cliques three intra-episode siblings, zero likelihood given polyallelic data:  Whereas, relationships non-zero likelihood given biallelic data:","code":"simulate_data <- function(marker_cardinality){      # Magic numbers / quantities   set.seed(5) # For reproducibility   n_markers <- 200 # Number of markers   n_strangers <- 3 # Number of stranger parasites   n_oocysts <- 2 # Number of oocysts to draw from      # Derived quantities   alleles <- letters[1:marker_cardinality]   markers <- paste0(\"m\", 1:n_markers) # Marker names      # Uniform allele frequencies    fs <- sapply(markers, simplify = FALSE,                 function(m) setNames(rep(1/marker_cardinality, marker_cardinality), alleles))      # Sample strangers   strangers <- sapply(1:n_strangers, function(i) {     sapply(markers, function(t) sample(names(fs[[t]]), size = 1, prob = fs[[t]]))   })      # Designate strangers   parents <- strangers[, 1:2]      # Map the markers to chromosomes. Assume equally sized chromosomes — reasonable   # if and only if we later assume an equal number of crossovers per chromosome   chrs_per_marker <- round(seq(0.51, 14.5, length.out = n_markers))      # Sample parental allocations dependently per-oocyst    cs <- lapply(1:n_oocysts, function(o) recombine_parent_ids(chrs_per_marker))      # Construct children from parental allocations    all_children <- lapply(1:n_oocysts, function(o) {     oocyst_chidren <- sapply(1:n_markers, function(i) {       sapply(1:ncol(cs[[o]]), function(j) parents[i,cs[[o]][i,j]])     })     colnames(oocyst_chidren) <- markers     return(oocyst_chidren)   })      # Make enrolment infection   enrol <- apply(rbind(all_children[[1]][1:2,],                         all_children[[2]][1:2,],                         strangers[,3]), 2, unique, simplify = F)      # Make paired data   data <- list(enrol = enrol, recur = as.list(all_children[[1]][1,]))      return(list(data = data, fs = fs)) } polyallelic <- simulate_data(10)  determine_MOIs(polyallelic$data) #> [1] 3 1 biallelic <- simulate_data(2)  determine_MOIs(biallelic$data) #> [1] 2 1 ppost <- suppressMessages(compute_posterior(y = polyallelic$data,                                              fs = polyallelic$fs,                                              return.logp = T)) bpost <- suppressMessages(compute_posterior(y = biallelic$data,                                              fs = biallelic$fs,                                              MOIs = c(3,1), return.logp = T))  ppost$marg #>               C         L             I #> recur 0.6666667 0.3333333 2.708985e-116 bpost$marg #>               C         L            I #> recur 0.6666663 0.3333337 4.625927e-18 llikes <- sapply(bpost$RGs, function(RG) RG$logp) # Extract log likelihoods any(is.infinite(llikes)) # Are there any minus infinity log likelihoods? #> [1] FALSE"},{"path":"https://aimeertaylor.github.io/Pv3Rs/articles/intra-episode-siblings.html","id":"contribution-to-upper-bounds","dir":"Articles","previous_headings":"","what":"Contribution to upper bounds","title":"Explore treatment of intra-episode siblings","text":"summation graphs cliques three siblings possibly redundant given graphs practical support. Even graphs zero likelihood, contribute maximum probabilities recrudescence / reinfection conditionally uniform prior graphs. However, upper bounds probability reinfection / recrudescence given single recurrence contribution small, especially reinfection:   recrudescence, 3 MOI vectors (circled plot ) result absolute difference greater 0.0175. feature large MOIs (MOI vectors 5 2 , 6 2 , 7 1 ) thus whose graph spaces include graphs largest cliques intra-episode siblings. contribution likely even smaller vectors three MOIs computationally feasible Pv3Rs, constituent MOIs necessarily less 7 (recall computationally feasible MOI vectors sum eight).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Aimee Taylor. Author, maintainer. Yong See Foo. Author. Mans Magnusson. Contributor. l'INSTITUT PASTEUR. Copyright holder. European Union, Project 101110393. Funder.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Taylor , Foo Y (2025). Pv3Rs: Estimate Cause Recurrent Vivax Malaria using Genetic Data. R package version 0.0.0.9000, https://aimeertaylor.github.io/Pv3Rs/.","code":"@Manual{,   title = {Pv3Rs: Estimate the Cause of Recurrent Vivax Malaria using Genetic Data},   author = {Aimee Taylor and Yong See Foo},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://aimeertaylor.github.io/Pv3Rs/}, }"},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"pv3rs-","dir":"","previous_headings":"","what":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"R package Plasmodium vivax molecular correction via statistical genetic inference Relapse Recrudescence Reinfection core function, compute_posterior(), computes per-person posterior probabilities relapse, recrudescence, reinfection (recurrence states) using P. vivax genetic data two episodes. fully understand core function, addition reading README entirety pre-print cited , recommend reading vignette(\"demonstrate-usage\", \"Pv3Rs\") Understand posterior probabilities. Two important features: plot_data() visualises genetic data molecular correction, regardless analytical method (e.g., Plasmodium falciparum data intended analysis using match-counting algorithm). plot_simplex() can used visualise per-recurrence probabilities relapse, recrudescence, reinfection, probability triplet summing one.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"please-be-aware-of-the-following-points","dir":"","previous_headings":"","what":"Please be aware of the following points!","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Pv3Rs R package yet peer-reviewed thus liable modification. model described preprint Taylor, Foo & White, 2022, building prototype Taylor & Watson et al. 2019.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"prior-considerations","dir":"","previous_headings":"Please be aware of the following points!","what":"Prior considerations:","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Genetic data modelled using Bayesian model, whose prior ideally informative ([2] priors generated time--event model built James Watson) cause recurrent P. vivax malaria always identifiable genetic data alone: data consistent recurrent parasites relatively unrelated preceding infections, reinfection relapse plausible; meanwhile, data compatible recurrent parasites clones preceding infection, recrudescence relapse plausible. main Pv3Rs function, compute_posterior(), applied P. falciparum setting prior probability relapse zero, genotyping errors, accounted current Pv3Rs model, liable lead misclassification recrudescence reinfection prior probability relapse zero (recrudescence relapse prior probability relapse exceeds zero).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"notable-assumptions-and-limitations","dir":"","previous_headings":"Please be aware of the following points!","what":"Notable assumptions and limitations:","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"model, Pv3Rs makes various assumptions limit capabilities settings.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"mutually-exclusive-recurrent-states","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Mutually exclusive recurrent states","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Recurrence states modelled mutually exclusive, suitable studies participants actively followed frequently detected infections treated extent parasitaemia drops detectable level recurrence, recurrence occurs. studies untreated accumulated infections, outputs may meaningful.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"unmodelled-complexities","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Unmodelled complexities","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"model complexities around molecular correction. example, population structure, including household effects; failure capture low-density clones blood sample limited volume [Snounou & Beck, 1998]; hidden biomass spleen bone marrow [Markus, 2019]. Users must interpret outputs context study methods. example, expect Pv3Rs output probable relapse person reinfected new mosquito parasites recently related caused previous infection, might happen household transmission chains.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"sibling-misspecification","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Sibling misspecification","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Relapsing parasites siblings parasites previous infections can meiotic, parent-child-like, regular half siblings, model sibling parasites regular siblings via following assumptions: Allele inheritance independent (true meiotic siblings) Aibling relationships transitive (true parent-child-like trios half-sibling trios) Alleles sibling cluster drawn two parental alleles (true half siblings) experience, half sibling misspecification leads misclassification relapses reinfections; see Understand half-sibling misspecification. descriptive study explore extent half-sibling misspecification recommended (example provided upcoming manuscript).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"observation-errors-and-de-novo-mutations","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Observation errors and de novo mutations","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"model undetected alleles, genotyping errors, de novo mutations. Recrudescent parasites modelled perfect clones Pv3Rs. , posterior probability recrudescence rendered zero errors mutations. becomes likely data markers. Sensitivity analyses explore impact errors mutations recurrence state probabilities merited.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"interpreting-probable-reinfection-and-recrudescence","dir":"","previous_headings":"Please be aware of the following points! > Notable assumptions and limitations:","what":"Interpreting probable reinfection and recrudescence","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"data sufficiently informative distinguish recrudescence relapse (reinfection relapse), posterior probabilities recrudescence relapse (reinfection relapse) heavily influenced model assumption relationship graphs; see Understand graph prior ramifications. development biologically-principled generative model parasite relationships merited.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"computational-limits","dir":"","previous_headings":"Please be aware of the following points!","what":"Computational limits:","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Pv3Rs scales hundreds markers whole-genome sequence (WGS) data. recommend running compute_posterior() data whose total genotype count (sum per-episode multiplicities infection) exceeds eight. total genotype counts exceeds eight multiple recurrences, might possible compute posterior probabilities analysing episodes pairwise (approach used [2] ’re working currently improved version). per-marker allele limit compute_posterior() untested. high marker cardinalities lead small allele frequencies thus underflow problems.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"population-level-allele-frequencies","dir":"","previous_headings":"Please be aware of the following points!","what":"Population-level allele frequencies:","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"addition P. vivax allelic data two episodes, compute_posterior() requires input population-level allele frequencies. minimise bias due within-host selection recrudescent parasites, recommend using enrolment episodes estimate population-level allele frequencies, ideally enrolment episodes study participants selected random, study participants experience recurrence. said, recurrences either reinfections relapses, draws mosquito population (albeit delayed draw case relapse), assuming systematic within-patient selection (might occur infections encounter lingering drug pressure), estimates based episodes unbiased precise based enrolment episodes .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"read-count-data","dir":"","previous_headings":"Please be aware of the following points!","what":"Read-count data:","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"Unfortunately, Pv3Rs model exploit data read counts present. However, read-count data used compute population-level allele frequencies, assuming biased experimental artefacts.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimate the Cause of Recurrent Vivax Malaria using Genetic Data","text":"","code":"# Install or update devtools from CRAN install.packages(\"devtools\")  # Install R.rsp, required for LaTeX vignette building install.packages(\"R.rsp\")  # Install Pv3Rs from GitHub  # We recommend doing this in RStudio: RStudio installs pandoc, required for # vignette building. If not, you might need to install pandoc and check its # path; otherwise set build_vignettes = FALSE devtools::install_github(\"aimeertaylor/Pv3Rs\", build_vignettes = TRUE)  # Load and attach Pv3Rs library(Pv3Rs)  # List links to all available documentation help(package = \"Pv3Rs\")  # List links to vignettes vignette(package = \"Pv3Rs\")  # View function documentation, e.g.,  ?compute_posterior"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/Pv3Rs-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Pv3Rs: Estimate the Cause of Recurrent Vivax Malaria using Genetic Data — Pv3Rs-package","title":"Pv3Rs: Estimate the Cause of Recurrent Vivax Malaria using Genetic Data — Pv3Rs-package","text":"Compute per-person posterior probabilities recurrent Plasmodium vivax (Pv) recurrence recrudescence, relapse, reinfection (3Rs) using per-person P. vivax genetic data two episodes.","code":""},{"path":[]},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/Pv3Rs-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pv3Rs: Estimate the Cause of Recurrent Vivax Malaria using Genetic Data — Pv3Rs-package","text":"Maintainer: Aimee Taylor aimee.taylor@pasteur.fr (ORCID) Authors: Yong See Foo contributors: Mans Magnusson [contributor] l'INSTITUT PASTEUR [copyright holder] European Union, Project 101110393 [funder]","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"Converts RG encoded list igraph object, requires memory allocation can plotted using plot_RG.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"","code":"RG_to_igraph(RG, MOIs)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"RG List encoding RG; see Value enumerate_RGs igraph = FALSE. MOIs Vector per-episode multiplicities infection (MOIs), .e., numbers per-episode genotypes / vertices; adds graph attribute used plot_RG group genotypes / vertices episode.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"weighted graph whose edge weights 1 0.5 encode clonal sibling relationships, respectively.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/RG_to_igraph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts a relationship graph (RG) encoded as a list to an igraph object — RG_to_igraph","text":"","code":"MOIs <- c(3,2) set.seed(6) RG_as_list <- sample_RG(MOIs, igraph = FALSE) RG_as_igraph <- RG_to_igraph(RG_as_list,  MOIs)  # RG encoded as a list requires less memory allocation utils::object.size(RG_as_list) #> 2512 bytes utils::object.size(RG_as_igraph) #> 4568 bytes  # RG encoded as an igraph object can be plotted using plot_RG() and # manipulated using igraph functions plot_RG(RG_as_igraph, margin = rep(0,4), vertex.label = NA)   # Edge weights 1 and 0.5 encode clonal and sibling relationships igraph::E(RG_as_igraph)$weight #> [1] 0.5 0.5 1.0  # Vertex attribute group encodes episode membership igraph::V(RG_as_igraph)$group #> [1] 1 1 1 2 2"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"Computes per-person posterior probabilities P. vivax recurrence states — recrudescence, relapse, reinfection — using per-person genetic data two episodes. usage, see Examples vignette(\"demonstrate-usage\") — clickable online (offline link). complete understanding posterior output, see \"Understand posterior probabilities\". Note: progress bar may increment non-uniformly (see Details); may appear stuck computations ongoing.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"","code":"compute_posterior(   y,   fs,   prior = NULL,   MOIs = NULL,   return.RG = FALSE,   return.logp = FALSE,   progress.bar = TRUE )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"y List lists encoding allelic data. outer list contains episodes chronological order. inner list contains named markers per episode. Marker names must consistent across episodes. NA indicates missing marker data; otherwise, specify per-marker vector distinct alleles detected (presently, compute_posterior support data proportional abundance detected alleles). Repeat alleles NA entries within allelic vectors ignored. Allele names arbitrary, allowing different data types, must correspond frequency names. fs List per-marker allele frequency vectors, names matching marker names y. Per-marker alleles frequencies mut contain one frequency per named allele, names matching alleles y. Per-marker frequencies must sum one. prior Matrix prior probabilities recurrence states per episode, rows episodes chronological order, columns named \"C\", \"L\", \"\" recrudescence, relapse reinfection, respectively. Row names ignored. NULL (default), per-episode recurrence states assumed equally likely priori. MOIs Vector per-episode multiplicities infection (MOIs); Pv3Rs model assumes genotyping errors, MOIs must greater equal parsimonious MOI estimates compatible data; see determine_MOIs(y). estimates used MOIs = NULL (default). return.RG Logical; returns relationship graphs (default FALSE). Automatically set TRUE return.logp = TRUE. return.logp Logical; returns log-likelihood relationship graph (default FALSE). Setting TRUE disables permutation symmetry optimisation thus increases runtime, especially MOIs large. affect output posterior probabilities; see vignette(\"demonstrate-usage\") — clickable online (offline link) — also contains example permutation symmetry. progress.bar Logical; show progress bars (default TRUE). Note progress bar may update non-uniformly.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"List containing: marg Matrix marginal posterior probabilities recurrence, rows recurrences columns \"C\" (recrudescence), \"L\" (relapse), \"\" (reinfection). marginal probability sums subset joint probabilities. example, marginal probability \"C\" first two recurrences sums joint probabilities \"CC\", \"CL\", \"CI\". joint Vector joint posterior probabilities recurrence state sequence; within sequence \"C\", \"L\", \"\" used . RGs List lists encoding relationship graphs; returned return.RG = TRUE (default FALSE), log-likelihoods return.logp = TRUE (default FALSE). relationship graph encoded list can converted igraph object using RG_to_igraph thus plotted using plot_RG. details relationship graphs, see enumerate_RGs.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"compute_posterior() computes posterior probabilities proportional likelihood multiplied prior. likelihood sums : ways phase allelic data onto haploid genotypes graphs relationships haploid genotypes ways partition alleles clusters identity--descent enumerate possible relationship graphs haploid genotypes, pairs genotypes can either clones, siblings, strangers. likelihood sequence recurrence states can determined likelihood relationship graphs compatible said sequence. details enumeration relationship graphs can found enumerate_RGs. relationship graph, model sums possible identity--descent partitions. graphs compatible partitions others, log p(Y|RG) progress bar may advance non-uniformly. recommend running `compute_posterior() total genotype count (sum MOIs) exceeds eight many relationship graphs. Notable model assumptions limitations: siblings regular siblings Recrudescent parasites derive immediately preceding episode Recrudescence, relapse reinfection mutually exclusive Undetected alleles, genotyping errors, de novo mutations modelled Population structure various complexities confound molecular correction modelled","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/compute_posterior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute posterior probabilities of P. vivax recurrence states — compute_posterior","text":"","code":"# Numerically named alleles y <- list(enrol = list(m1 = c('3','2'), m2 = c('1','2')),           recur1 = list(m1 = c('1','4'), m2 = c('1')),           recur2 = list(m1 = c('1'), m2 = NA)) fs <- list(m1 = c('1' = 0.78, '2' = 0.14, '3' = 0.07, '4' = 0.01),            m2 = c('1' = 0.27, '2' = 0.73)) compute_posterior(y, fs, progress.bar = FALSE) #> Number of valid relationship graphs (RGs) is 250 #> Computing log p(Y|RG) for 250 RGs #> Finding log-likelihood of each vector of recurrence states #>  #> $marg #>                C         L         I #> recur1 0.0000000 0.1949556 0.8050444 #> recur2 0.2938829 0.2476598 0.4584573 #>  #> $joint #>         CC         LC         IC         CL         LL         IL         CI  #> 0.00000000 0.05539481 0.23848807 0.00000000 0.05314490 0.19451493 0.00000000  #>         LI         II  #> 0.08641590 0.37204139  #>    # Arbitrarily named alleles, plotting per-recurrence posteriors y <- list(enrolment = list(marker1 = c(\"Tinky Winky\", \"Dipsy\"),                           marker2 = c(\"Tinky Winky\", \"Laa-Laa\", \"Po\")),           recurrence = list(marker1 = \"Tinky Winky\",                           marker2 = \"Laa-Laa\")) fs <- list(marker1 = c(\"Tinky Winky\" = 0.4, \"Dipsy\" = 0.6),            marker2 = c(\"Tinky Winky\" = 0.1, \"Laa-Laa\" = 0.1, \"Po\" = 0.8)) plot_simplex(p.coords = compute_posterior(y, fs, progress.bar = FALSE)$marg) #> Number of valid relationship graphs (RGs) is 30 #> Computing log p(Y|RG) for 30 RGs #> Finding log-likelihood of each vector of recurrence states #>     # Episode names are cosmetic: \"r1_prior\" is returned for \"r2\" y <- list(enrol = list(m1 = NA), r2 = list(m1 = NA), r1 = list(m1 = NA)) prior <- matrix(c(0.6,0.7,0.2,0.3,0.2,0), ncol = 3,                 dimnames = list(c(\"r1_prior\", \"r2_prior\"), c(\"C\", \"L\", \"I\"))) suppressMessages(compute_posterior(y, fs = list(m1 = c(a = 1)), prior))$marg #> Warning: Data and prior episode names disagree #> Warning: Marker m1 has data on fewer than two episodes #> Warning: Episodes enrol & r2 & r1 have no data #>      C   L   I #> r2 0.6 0.2 0.2 #> r1 0.7 0.3 0.0 prior #>            C   L   I #> r1_prior 0.6 0.2 0.2 #> r2_prior 0.7 0.3 0.0   # Prior is returned when all data are missing y_missing <- list(enrol = list(m1 = NA), recur = list(m1 = NA)) suppressMessages(compute_posterior(y_missing, fs = list(m1 = c(\"A\" = 1)))) #> Warning: Marker m1 has data on fewer than two episodes #> Warning: Episodes enrol & recur have no data #> $marg #>               C         L         I #> recur 0.3333333 0.3333333 0.3333333 #>  #> $joint #>         C         L         I  #> 0.3333333 0.3333333 0.3333333  #>    # Return of the prior re-weighted to the exclusion of recrudescence: suppressMessages(compute_posterior(y_missing, fs = list(m1 = c(\"A\" = 1)),                  MOIs = c(1,2))) #> Warning: Marker m1 has data on fewer than two episodes #> Warning: Episodes enrol & recur have no data #> $marg #>       C   L   I #> recur 0 0.5 0.5 #>  #> $joint #>   C   L   I  #> 0.0 0.5 0.5  #>  # (Recrudescing parasites are clones of previous blood-stage parasites. The # Pv3R model assumes no within-host de-novo mutations and perfect allele # detection. As such, recrudescence is incompatible with an MOI increase on # the preceding infection.)   # Beware provision of unpaired data: the prior is not necessarily returned; # for more details, see link above to \"Understand posterior estimates\" y <- list(list(m1 = c('1', '2')), list(m1 = NA)) fs <- list(m1 = c('1' = 0.5, '2' = 0.5)) suppressMessages(compute_posterior(y, fs))$marg #> Warning: Marker m1 has data on fewer than two episodes #> Warning:  #>              C         L         I #> [1,] 0.3292683 0.3414634 0.3292683"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine multiplicities of infection (MOIs) — determine_MOIs","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"Returns MOI estimate episode based allelic diversity across markers.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"","code":"determine_MOIs(y, return.names = FALSE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"y List lists encoding allelic data; see compute_posterior details. outer list contains episodes chronological order. inner list contains named markers per episode. marker, one must specify allelic vector: set distinct alleles detected marker; NA marker data missing. return.names Logical; TRUE y named episodes, episode names returned.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"Numeric vector containing one MOI estimate per episode, estimate representing maximum number distinct alleles observed marker per episode.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"true MOI number genetically distinct groups clonal parasites within infection. Give take de novo mutations, parasites within clonal group share DNA sequence, call genotype. , MOIs distinct parasite genotype counts. Pv3Rs model assumption genotyping errors, true MOI episode greater equal maximum distinct allele count marker data episode. words, assumption genotyping errors, maximum distinct allelic counts parsimonious MOI estimates compatible data. default, MOI estimates used compute_posterior.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/determine_MOIs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine multiplicities of infection (MOIs) — determine_MOIs","text":"","code":"y <- list(enrol = list(m1 = c(\"A\", \"B\"), m2 = c(\"A\"), m3 = c(\"C\")),           recur = list(m1 = c(\"B\"), m2 = c(\"B\", \"C\"), m3 = c(\"A\", \"B\", \"C\"))) determine_MOIs(y) # returns c(2, 3) #> [1] 2 3"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":null,"dir":"Reference","previous_headings":"","what":"Enumerate relationship graphs (RGs) — enumerate_RGs","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"RG graph per-person parasite genotypes (vertex), edges clone sibling genotypes. Valid RGs satisfy: Subgraphs induced clone edges cluster graphs. Subgraphs induced clone plus sibling edges cluster graphs. Clone edges link genotypes different episodes.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"","code":"enumerate_RGs(MOIs, igraph = TRUE, progress.bar = TRUE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"MOIs Vector per-episode multiplicities infection (MOIs), .e., numbers per-episode genotypes / vertices. igraph Logical; returns RGs igraph objects (default TRUE). progress.bar Logical; show progress bar (default TRUE).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"list RGs. igraph = FALSE, RG list length four : clone List vectors encoding genotypes per clonal cell. clone.vec Numeric vector clonal cell membership genotype. sib List vectors encoding clonal cells per sibling cell. sib.vec Numeric vector sibling cell membership clonal cell. igraph = TRUE (default), RG encoded igraph object (see RG_to_igraph).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"RGs generated enumerating nested set partitions specific constraints; see vignette(\"enumerate\") (offline link). nested set parition RG. Clone edges induce cluster graph, equivalent partition genotypes, intra-episode clones allowed. Sibling edges refine clone partition, constraints (intra-episode siblings allowed). nested set partition encoded list. partition represented list vectors (either clone sib) membership vector (either clone.vec sib.vec). default, RG encoded list converted igraph object.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/enumerate_RGs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Enumerate relationship graphs (RGs) — enumerate_RGs","text":"","code":"graphs <- enumerate_RGs(c(2, 1, 2), progress.bar = FALSE) # nine graphs #> Number of valid relationship graphs (RGs) is 250"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":null,"dir":"Reference","previous_headings":"","what":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"posterior mean multinomial-Dirichlet model uniform prior fit data allele prevalence initial episodes ys_VHX_BPD. model fit allele prevalence (observed) allele frequency ( requires integrating-unknown multiplicities infection) liable underestimate frequencies common alleles overestimate rare detected alleles.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"","code":"fs_VHX_BPD"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"list nine markers; marker named vector allele frequencies sum one.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/fs_VHX_BPD.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Allele frequencies computed using example Plasmodium vivax data — fs_VHX_BPD","text":"https://zenodo.org/records/3368828 https://github.com/aimeertaylor/Pv3Rs/blob/main/data-raw/fs_VHX_BPD.R","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a relationship graph (RG) — plot_RG","title":"Plot a relationship graph (RG) — plot_RG","text":"function wrapper around plot.igraph, written group parasite genotypes episode spatially using vertex colour (specifically, parasite genotypes within episodes vertically distributed horizontal jitter layout..group = TRUE (default), equicolored), ensure clone sibling edges plotted using different line types.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a relationship graph (RG) — plot_RG","text":"","code":"plot_RG(   RG,   layout.by.group = TRUE,   vertex.palette = \"Set2\",   edge.lty = c(sibling = \"dashed\", clone = \"solid\"),   edge.col = c(sibling = \"black\", clone = \"black\"),   edge.width = 1.5,   ... )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a relationship graph (RG) — plot_RG","text":"RG igraph object encoding RG; see RG_to_igraph. layout..group Logical; TRUE (default) overrides default layout plot.igraph vertices represent parasite genotypes different episodes distributed horizontally vertices represent genotypes within episodes distributed vertically. vertex.palette character string specifying RColorBrewer palette. Overrides default palette plot.igraph. edge.lty Named vector edge line types corresponding different relationships. edge.col Named vector edge colours corresponding different relationships. edge.width Overrides default edge.width plot.igraph. ... Additional arguments pass plot.igraph, e.g., edge.curved.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a relationship graph (RG) — plot_RG","text":"None","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"provenance","dir":"Reference","previous_headings":"","what":"Provenance","title":"Plot a relationship graph (RG) — plot_RG","text":"function adapted plot_Vivax_model https://github.com/jwatowatson/RecurrentVivax/blob/master/Genetic_Model/iGraph_functions.R.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_RG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a relationship graph (RG) — plot_RG","text":"","code":"RGs <- enumerate_RGs(c(2, 1, 1), progress.bar = FALSE) #> Number of valid relationship graphs (RGs) is 48 cpar <- par(no.readonly = TRUE) # record current par before changing par(mfrow = c(3, 4), mar = c(0.1, 0.1, 0.1, 0.1)) for (i in 12:23) {   plot_RG(RGs[[i]],   edge.col = c(sibling = \"gray\", clone = \"black\"),   edge.lty = c(sibling = \"dotted\", clone = \"solid\"),   edge.curved = 0.1)   box() }  par(cpar) # reset par"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots the data — plot_data","title":"Plots the data — plot_data","text":"Plots allelic data grid coloured rectangles.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots the data — plot_data","text":"","code":"plot_data(   ys,   fs = NULL,   person.vert = FALSE,   mar = c(1.5, 3.5, 1.5, 1),   gridlines = TRUE,   palette = RColorBrewer::brewer.pal(12, \"Paired\"),   marker.annotate = TRUE,   legend.lab = \"Allele frequencies\",   legend.line = 0.2,   legend.ylim = c(0.05, 0.2),   cex.maj = 0.7,   cex.min = 0.5,   cex.text = 0.5,   x.line = 0.2,   y.line = 2.5 )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots the data — plot_data","text":"ys Nested list per-person, per-episode, per-marker allelic data; see Examples compute_posterior() expected per-person structure. fs per-marker list numeric vectors allele frequencies. NULL (default), alleles present ys shown legend, per-marker alleles represented equally. colour scheme adaptive, allele may different colours given different ys. fs specified, alleles fs feature legend areas proportional allele frequencies, common alleles occupy larger areas rarer alleles. Specify fs fix allele colour scheme across plots different ys. person.vert Logical. TRUE (default), person IDs printed vertically; otherwise, printed horizontally. mar Vector numbers lines margin main plot; see mar entry par. gridlines Logical. true (default), white grid lines separating people markers drawn. palette Colour palette alleles, see Value section brewer.pal. Generally, colours interpolated: marker d possible alleles, colours used 1/(d+1), ..., d/(d+1) quantiles palette ensure markers different allele counts use different colours. marker.annotate Logical. true (default), names alleles printed top colours legend. legend.lab Label axis legend. Defaults \"Allele frequencies\". Set NA omit label; , consider adjusting legend.ylim use plotting space. legend.line Distance (character heights) colour bar legend label (defaults 1.5). legend.ylim Vector specifying y-coordinate limits legend device coordinates (0 1). Defaults c(0.05, 0.2). cex.maj Numeric; font scaling major axis labels. cex.min Numeric; font scaling minor axis labels. cex.text Numeric; font scaling allele labels. x.line Distance top x-axis x-axis label, defaults 0.2. y.line Distance left y-axis y-axis label, defaults 2.5.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots the data — plot_data","text":"None","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plots the data — plot_data","text":"function plots alleles (colours), observed different episodes (columns), different markers (rows), episodes grouped person. Per-person episodes plotted left right chronological order. multiple alleles detected marker within episode, corresponding grid element subdivided vertically different colours. default, markers ordered lexicographically. fs provided, markers ordered match order within fs. legend depicts alleles marker vertical order main plot. default colour scheme adaptive, designed visually differentiate alleles clearly possible maximizing hue contrast within qualitative palette. Interpolation used make different colour palettes markers different numbers possible alleles. names alleles printed top colours marker.annotate set TRUE.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots the data — plot_data","text":"","code":"# Plot example Plasmodium vivax data set mar <- c(2, 3.5, 1.5, 1) # extra vertical margin for vertical person labels plot_data(ys = ys_VHX_BPD, person.vert = TRUE, mar = mar, legend.lab = NA)  plot_data(ys = ys_VHX_BPD, person.vert = TRUE, mar = mar, legend.lab = NA,           fs = fs_VHX_BPD)  plot_data(ys = ys_VHX_BPD, person.vert = TRUE, mar = mar, legend.lab = NA,           fs = fs_VHX_BPD, marker.annotate = FALSE)   # Demonstrating the adaptive nature of the colour scheme: ys <- ys_VHX_BPD[\"VHX_52\"] # A single person plot_data(ys, fs = fs_VHX_BPD, marker.annotate = FALSE) # Colours match above  plot_data(ys) # Colours and the legend adapt to alleles detected in VHX_52"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots a 2D simplex — plot_simplex","title":"Plots a 2D simplex — plot_simplex","text":"Plots 2D simplex (triangle unit sides centered origin) onto per-recurrence posterior probabilities recrudescence, relapse, reinfection (probability triplet summing one) can projected; see project2D() Examples .","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots a 2D simplex — plot_simplex","text":"","code":"plot_simplex(   v.labels = c(\"Recrudescence\", \"Relapse\", \"Reinfection\"),   v.cutoff = 0.5,   v.colours = c(\"yellow\", \"purple\", \"red\"),   plot.tri = TRUE,   p.coords = NULL,   p.labels = rownames(p.coords),   p.labels.pos = 3,   p.labels.cex = 1,   ... )"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots a 2D simplex — plot_simplex","text":"v.labels Vertex labels anticlockwise top (default: \"Recrudescence\", \"Relapse\", \"Reinfection\"). NULL, vertices labelled. v.cutoff Number 0.5 1 separates lower vs higher probability regions. Use caution recrudescence reinfection classification; see \"Understand posterior probabilities\". v.colours Vertex colours anticlockwise top. plot.tri Logical; draws triangular boundary TRUE (default). p.coords Matrix 3D simplex coordinates (e.g., per-recurrence probabilities recrudescence, relapse reinfection), one vector 3D coordinates per row, row projected onto 2D coordinates using project2D() plotted single simplex point using graphics::points(). user provides vector encoding probability triplet summing one, converted matrix one row. p.labels Labels points p.coords (default row names p.coords) labels NA. p.labels.pos Position p.labels: 1 = , 2 = left, 3 = (default) 4 = right. Can single value vector. p.labels.cex Size expansion p.labels passed text. ... Additional parameters passed graphics::points().","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots a 2D simplex — plot_simplex","text":"None","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/plot_simplex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots a 2D simplex — plot_simplex","text":"","code":"# Plot 2D simplex plot_simplex(p.coords = diag(3),              p.labels = c(\"(1,0,0)\", \"(0,1,0)\", \"(0,0,1)\"),              p.labels.pos = c(1,3,3))   # ============================================================================== # Given data on an enrollment episode and a recurrence, # compute the posterior probabilities of the 3Rs and plot the deviation of the # posterior from the prior # ==============================================================================  # Some data: y <- list(list(m1 = c('a', 'b'), m2 = c('c', 'd')), # Enrollment episode           list(m1 = c('a'), m2 = c('c'))) # Recurrent episode  # Some allele frequencies: fs <- list(m1 = setNames(c(0.4, 0.6), c('a', 'b')),            m2 = setNames(c(0.2, 0.8), c('c', 'd')))  # A vector of prior probabilities: prior <- array(c(0.2, 0.3, 0.5), dim = c(1,3),                dimnames = list(NULL, c(\"C\", \"L\", \"I\")))  # Compute posterior probabilities post <- compute_posterior(y, fs, prior, progress.bar = FALSE) #> Number of valid relationship graphs (RGs) is 9 #> Computing log p(Y|RG) for 9 RGs #> Finding log-likelihood of each vector of recurrence states #>   # Plot simplex with the prior and posterior plot_simplex(p.coords = rbind(prior, post$marg),              p.labels = c(\"Prior\", \"Posterior\"),              pch = 20)  # Add the deviation between the prior and posterior: requires obtaining 2D # coordinates manually xy_prior <- project2D(as.vector(prior)) xy_post <- project2D(as.vector(post$marg)) arrows(x0 = xy_prior[\"x\"], x1 = xy_post[\"x\"],        y0 = xy_prior[\"y\"], y1 = xy_post[\"y\"], length = 0.1)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":null,"dir":"Reference","previous_headings":"","what":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"Project three probabilities sum one (e.g., per-recurrence probabilities recrudescence, relapse reinfection) onto coordinates 2D simplex centred origin (.e., triangle centred (0,0) unit-length sides).","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"","code":"project2D(v)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"v numeric vector three numbers zero one sum one.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"numeric vector two coordinates can used plot probability vector v origin-centred 2D simplex.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"top, left, right vertices 2D simplex correspond first, second third entries v, respectively. probability proportional distance point simplex side opposite corresponding probability; see Examples plot_simplex() details.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/project2D.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project 3D probability coordinates onto 2D simplex coordinates — project2D","text":"","code":"probabilities_of_v1_v2_v3 <- c(0.75,0.20,0.05) coordinates <- project2D(v = probabilities_of_v1_v2_v3)  # Plot probability vector on 2D simplex plot_simplex(v.labels = c(\"v1\", \"v2\", \"v3\")) points(x = coordinates[1], y = coordinates[2], pch = 20)  # Plot the distances that represent probabilities # get vertices, get points on edges by orthogonal projection, plot arrows v <- apply(matrix(c(1,0,0,0,1,0,0,0,1), nrow = 3), 1, project2D) p3 <- v[,1] + sum((coordinates - v[,1]) * (v[,2] - v[,1])) * (v[,2] - v[,1]) p1 <- v[,2] + sum((coordinates - v[,2]) * (v[,3] - v[,2])) * (v[,3] - v[,2]) p2 <- v[,3] + sum((coordinates - v[,3]) * (v[,1] - v[,3])) * (v[,1] - v[,3]) arrows(x0 = coordinates[1], y0 = coordinates[2], x1 = p1[1], y1 = p1[2], length = 0.1) arrows(x0 = coordinates[1], y0 = coordinates[2], x1 = p2[1], y1 = p2[2], length = 0.1) arrows(x0 = coordinates[1], y0 = coordinates[2], x1 = p3[1], y1 = p3[2], length = 0.1)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample a relationship graph (RG) — sample_RG","title":"Sample a relationship graph (RG) — sample_RG","text":"Uses techniques enumerate_RGs sample single RG uniformly. clonal partitions generated, weighted number consistent sibling partitions. clonal partition sampled proportional weight, consistent sibling partition drawn uniformly. resulting nested partition represents RG; see enumerate_RGs details.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample a relationship graph (RG) — sample_RG","text":"","code":"sample_RG(MOIs, igraph = TRUE)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample a relationship graph (RG) — sample_RG","text":"MOIs Vector per-episode multiplicities infection (MOIs), .e., numbers per-episode genotypes / vertices. igraph Logical; TRUE (default), returns RG igraph object.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample a relationship graph (RG) — sample_RG","text":"RG encoded either igraph object (default), list; see enumerate_RGs details.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/sample_RG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample a relationship graph (RG) — sample_RG","text":"","code":"set.seed(1) RG <- sample_RG(c(3, 2)) plot_RG(RG, vertex.label = NA)"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Plasmodium vivax data — ys_VHX_BPD","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"Previously-published microsatellite data P. vivax parasites extracted study participants enrolled Best Primaquine Dose (BPD) Vivax History (VHX) trials; see Taylor & Watson et al. 2019 details genetic data; details VHX BPD trials, see Chu et al. 2018a Chu et al. 2018b, respectively.","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"","code":"ys_VHX_BPD"},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"list 217 study participants; study participant, list one episodes; episode, list three microsatellite markers; marker, vector observed alleles (repeat lengths). example: BPD_103 Study participant identifier: study participant 103 BPD trial BPD_103_1 Episode identifier: episode one study participant 103 BPD trial PV.3.27 Marker identifier: P. vivax 3.27 18 Allele identifier: 18 repeat lengths","code":""},{"path":"https://aimeertaylor.github.io/Pv3Rs/reference/ys_VHX_BPD.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example Plasmodium vivax data — ys_VHX_BPD","text":"https://zenodo.org/records/3368828 https://github.com/aimeertaylor/Pv3Rs/blob/main/data-raw/ys_VHX_BPD.R","code":""}]
